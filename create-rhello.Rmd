---
title: "Creating the ``r params$package_name`` R package"
author: "Your Name"
date: "The Date"
knit: litr::render
output: litr::litr_html_document
params:
  package_name: "FSHybridPLS" # <-- change this to your package name
  package_parent_dir: "." # <-- relative to this file's location
---

<!-- This Rmd file contains all the code needed to define an R package.  Press "Knit" in RStudio or more generally run `litr::render("name-of-this-file.Rmd")` to generate the R package.  Remember that when you want to modify anything about the R package, you should modify this document rather than the package that is outputted.
-->

## Package setup

We start by specifying the information needed in the DESCRIPTION file of the R package.

```{r package-setup, message=FALSE, results='hide'}
usethis::create_package(
  path = ".",
  fields = list(
    Package = params$package_name,
    Version = "0.0.0.9000",
    Title = "A Package That Says Hello",
    Description = "This package says hello.  But its actual purpose is to show how an R package can be completely coded in a single R markdown file.",
    Imports = "fda (>= 6.1.3)",
    `Authors@R` = person(
      given = "First",
      family = "Last",
      email = "you@gmail.com",
      role = c("aut", "cre")
      )
  )
)
usethis::use_mit_license(copyright_holder = "F. Last")
```

# Class predictor_hybrid
- Let $\{X^{(k)}\}_{k=1, \ldots, K}$ be a collection of random functions defined on unit hypercube domains $\mathcal{T}_k := [0,1]^{d_k}$ ($d_k \in \mathbb{N})$; i.e., $X^{(k)}: \mathcal{T}_k \rightarrow \mathbb{R}$.

- Assume that each $X^{(k)}$ is in $L^2(\mathcal{T}_k)$, a Hilbert space of square integrable functions with respect to Lebesgue measure $dt_k$ on $\mathcal{T}_k$. 

- Write  $X=(X^{(1)}, \ldots, X^{(K)})$ as a multivariate functional object that belongs to $\mathcal{F} = L^2(\mathcal{T}_1) \times \cdots \times L^2(\mathcal{T}_K)$---a cartesian product of individual $L^2(\mathcal{T}_k)$ spaces. 

- We can also express the functional object $X$ evaluated on the multi-dimensional argument $\mathbf{t} = (t_1, \ldots, t_k)^\top \in \mathcal{T} = \mathcal{T}_1 \times \cdots \times \mathcal{T}_K$ as a $K$-dimensional vector $X(\mathbf{t})=(X^{(1)}(t_1), \ldots, X^{(K)}(t_K))^\top$. 

- **Our strategy is to formulate a hybrid random object**, $\mathbf{W} = (X, \mathbf{Z})$, which combines $X$ and $p$-dimensional scalar covariate $\mathbf{Z}$ into an ordered pair belonging to $\mathcal{H} = \mathcal{F} \times \mathbb{R}^p$.  

- An alternative notation for the hybrid object can be obtained by evaluating its functional part on $\mathbf{t}$ and expressing it as a $(K+p)$-dimensional vector: $\mathbf{W}[\mathbf{t}] = (X(\mathbf{t}), \mathbf{Z})^\top$, with $X(\mathbf{t}) = (X^{(1)}(t_1), \ldots, X^{(K)}(t_K))^\top \in \mathbb{R}^K$ and $\mathbf{Z} = (Z_1, \ldots, Z_p)^\top  \in \mathbb{R}^p$.

- The hybrid object forms a Hilbert space, characterized by well-defined addition, scalar multiplication, and inner product operations. 

- The `predictor_hybrid` class is an S3 object designed to represent this structure. 

- We implement Hilbert space operations for this class, and our algorithm is built on these foundational operations.

The class definition is a simple list that contains a matrix and a collection of \code{fd} objects from the \code{fda} package, along with the necessary metadata.

```{r}
#' Create a predictor_hybrid object (S3 version)
#'
#' Constructs a hybrid predictor object that stores both scalar and functional predictors,
#' along with Jacobians and metadata.
#'
#' @param Z A numeric matrix of dimension \code{n_sample × n_scalar} representing scalar predictors.
#' @param functional_list A list of functional predictors (e.g., \code{fd} objects from the \code{fda} package).
#' @param jacobian_list A list of Jacobian matrices corresponding to the functional predictors.
#' @param n_basis_list A numeric vector indicating the number of basis functions for each functional predictor.
#' @param n_sample Number of observations (samples).
#' @param n_functional Number of functional predictors.
#' @param n_scalar Number of scalar predictors.
#'
#' @return A list of class \code{predictor_hybrid}.
#' @export
predictor_hybrid <- function(Z, functional_list, jacobian_list,
                             n_basis_list, n_sample, n_functional, n_scalar) {
  stopifnot(is.matrix(Z))
  stopifnot(length(functional_list) == n_functional)
  stopifnot(length(jacobian_list) == n_functional)
  stopifnot(length(n_basis_list) == n_functional)
  
  structure(
    list(
      Z = Z,
      functional_list = functional_list,
      jacobian_list = jacobian_list,
      n_basis_list = n_basis_list,
      n_sample = n_sample,
      n_functional = n_functional,
      n_scalar = n_scalar
    ),
    class = "predictor_hybrid"
  )
}
```



Let's write some tests to make sure the function behaves as desired:
```{r}
testthat::test_that("predictor_hybrid constructor works as expected (S3)", {
  Z <- matrix(rnorm(100 * 5), nrow = 100, ncol = 5)
  fd1 <- list(fdobj = "fd1 placeholder")
  fd2 <- list(fdobj = "fd2 placeholder")
  J1 <- matrix(runif(100), nrow = 10)
  J2 <- matrix(runif(200), nrow = 20)
  
  obj <- predictor_hybrid(
    Z = Z,
    functional_list = list(fd1, fd2),
    jacobian_list = list(J1, J2),
    n_basis_list = c(10, 20),
    n_sample = 100,
    n_functional = 2,
    n_scalar = 5
  )
  
  testthat::expect_s3_class(obj, "predictor_hybrid")
  testthat::expect_equal(nrow(obj$Z), 100)
  testthat::expect_equal(ncol(obj$Z), 5)
  testthat::expect_equal(length(obj$functional_list), 2)
  testthat::expect_equal(length(obj$jacobian_list), 2)
  testthat::expect_equal(obj$n_basis_list, c(10, 20))
  testthat::expect_equal(obj$n_sample, 100)
  testthat::expect_equal(obj$n_functional, 2)
  testthat::expect_equal(obj$n_scalar, 5)
})


```

## Basic arithmetic

### add.predictor_hybrid
Performs element-wise addition of two `predictor_hybrid` objects.  Functional predictors are combined using `plus.fd()` and `times.fd()` from the `fda` package.

- Usage

```r
add.predictor_hybrid(input, other, alpha = 1)
```

- Arguments:

  - `input`: A `predictor_hybrid` object.
  - `other`: Another `predictor_hybrid` object to be added.
  - `alpha`: A scalar multiplier applied to `other` before addition (default is 1).

- Value:
Returns a new `predictor_hybrid` object representing the result of the addition.

- Details: 
  - This function assumes both objects have the same number and structure of functional and scalar predictors.  
  - Functional parts are scaled by `alpha` using `times.fd()` and then summed using `plus.fd()`.  
  - Scalar predictors are added using standard matrix addition.

```{r}
#' Add two predictor_hybrid objects
#'
#' Performs element-wise addition of two predictor_hybrid objects.
#' Functional predictors are combined using `plus.fd()` and `times.fd()`.
#'
#' @param input A predictor_hybrid object.
#' @param other Another predictor_hybrid object.
#' @param alpha A numeric scalar multiplier for `other`.
#'
#' @return A new predictor_hybrid object representing the sum.
#' @export
add.predictor_hybrid <- function(input, other, alpha = 1) {
  if (input$n_functional != other$n_functional || input$n_scalar != other$n_scalar) {
    stop("Mismatch in number of predictors.")
  }
  
  # Optionally check that functional bases are the same
  # if (!is_same_basis(input, other)) stop("Different functional bases.")

  new_functional_list <- vector("list", input$n_functional)
  for (i in seq_len(input$n_functional)) {
    new_functional_list[[i]] <- plus.fd(
      input$functional_list[[i]],
      times.fd(alpha, other$functional_list[[i]])
    )
  }
  
  new_Z <- input$Z + alpha * other$Z
  
  predictor_hybrid(
    Z = new_Z,
    functional_list = new_functional_list,
    jacobian_list = input$jacobian_list,  # Assumes identical structure
    n_basis_list = input$n_basis_list,
    n_sample = input$n_sample,
    n_functional = input$n_functional,
    n_scalar = input$n_scalar
  )
}

```


```{r}
testthat::test_that("add.predictor_hybrid works for matching predictors", {
  suppressPackageStartupMessages(library(fda))

  Z1 <- matrix(1, nrow = 3, ncol = 2)
  Z2 <- matrix(2, nrow = 3, ncol = 2)
  
  basis <- fda::create.bspline.basis(c(0, 1), 5)
  fd1 <- fda::fd(coef = matrix(1, 5, 3), basisobj = basis)
  fd2 <- fda::fd(coef = matrix(2, 5, 3), basisobj = basis)
  
  obj1 <- predictor_hybrid(Z1, list(fd1), list(matrix(0)), c(5), 3, 1, 2)
  obj2 <- predictor_hybrid(Z2, list(fd2), list(matrix(0)), c(5), 3, 1, 2)
  
  obj3 <- add.predictor_hybrid(obj1, obj2, alpha = 1)
  
  testthat::expect_s3_class(obj3, "predictor_hybrid")
  testthat::expect_equal(obj3$Z, matrix(3, nrow = 3, ncol = 2))
  
  expected_coef <- matrix(3, 5, 3)
  testthat::expect_equal(
    unname(coef(obj3$functional_list[[1]])),
    unname(expected_coef)
  )
})


```
### subtr.predictor_hybrid
Performs element-wise subtraction of two `predictor_hybrid` objects.   Internally uses `add.predictor_hybrid(input, other, alpha = -1)` to compute the result by negating the second operand.

- Usage

```r
subtr.predictor_hybrid(input, other, alpha = 1)
```

- Arguments:

  - `input`: A `predictor_hybrid` object.
  - `other`: Another `predictor_hybrid` object to be subtracted.
  - `alpha`: A scalar multiplier applied to `other` before subtraction (default is 1).

- Value:  
Returns a new `predictor_hybrid` object representing the result of the subtraction.

- Details:  
  - This function assumes both objects have the same number and structure of functional and scalar predictors.  
  - It performs subtraction by internally calling `add.predictor_hybrid()` with `-alpha`.  
  - Functional parts are scaled using `times.fd()` and subtracted via `plus.fd()` with a negated factor.  
  - Scalar predictors are subtracted using standard matrix arithmetic.

```{r}
#' Subtract two predictor_hybrid objects
#'
#' Performs element-wise subtraction of two `predictor_hybrid` objects.
#' Internally uses `add.predictor_hybrid(input, other, alpha = -1)`.
#'
#' @param input A `predictor_hybrid` object.
#' @param other Another `predictor_hybrid` object to subtract.
#' @param alpha A scalar multiplier applied to `other` before subtraction (default is 1).
#'
#' @return A new `predictor_hybrid` object representing the result of subtraction.
#' @export
subtr.predictor_hybrid <- function(input, other, alpha = 1) {
  add.predictor_hybrid(input, other, alpha = -alpha)
}

```
We skip the unit test for this function.


### scalar_mul.predictor_hybrid
Multiplies all components of a `predictor_hybrid` object by a scalar. Functional components are scaled using `times.fd()` from the `fda` package, and scalar predictors are multiplied directly using matrix operations.

- Usage

```r
scalar_mul.predictor_hybrid(input, scalar)
```

- Arguments:

  - `input`: A `predictor_hybrid` object.
  - `scalar`: A numeric value used to scale both scalar and functional components.

- Value:  
Returns a new `predictor_hybrid` object with all components scaled by `scalar`.

- Details:  
  - Functional predictors are scaled using `times.fd(scalar, fd_obj)` for each element.  
  - Scalar predictors (the matrix `Z`) are scaled elementwise using matrix multiplication.

```{r}
#' Multiply a predictor_hybrid object by a scalar
#'
#' Performs scalar multiplication of both scalar and functional components 
#' of a `predictor_hybrid` object. Functional predictors are scaled using 
#' `times.fd()` from the `fda` package.
#'
#' @param input A `predictor_hybrid` object.
#' @param scalar A numeric value to multiply all components by.
#'
#' @return A new `predictor_hybrid` object scaled by `scalar`.
#' @export
scalar_mul.predictor_hybrid <- function(input, scalar) {
  new_functional_list <- lapply(
    input$functional_list,
    function(fd_obj) times.fd(scalar, fd_obj)
  )
  
  new_Z <- scalar * input$Z
  
  predictor_hybrid(
    Z = new_Z,
    functional_list = new_functional_list,
    jacobian_list = input$jacobian_list,
    n_basis_list = input$n_basis_list,
    n_sample = input$n_sample,
    n_functional = input$n_functional,
    n_scalar = input$n_scalar
  )
}
```

Here is a test code with two functional predictors:
```{r}
testthat::test_that("scalar_mul.predictor_hybrid works with two functional predictors", {
  suppressPackageStartupMessages(library(fda))
  
  # Scalar matrix
  Z <- matrix(2, nrow = 3, ncol = 2)
  
  # Create a shared basis for both functional predictors
  basis <- create.bspline.basis(c(0, 1), 5)
  
  # Two identical fd objects
  fd1 <- fd(coef = matrix(2, 5, 3), basisobj = basis)
  fd2 <- fd(coef = matrix(2, 5, 3), basisobj = basis)
  
  # Construct predictor_hybrid object
  obj <- predictor_hybrid(
    Z = Z,
    functional_list = list(fd1, fd2),
    jacobian_list = list(matrix(0), matrix(0)),
    n_basis_list = c(5, 5),
    n_sample = 3,
    n_functional = 2,
    n_scalar = 2
  )
  
  # Perform scalar multiplication
  scaled <- scalar_mul.predictor_hybrid(obj, 4)
  
  testthat::expect_s3_class(scaled, "predictor_hybrid")
  
  # Scalar part should be scaled
  testthat::expect_equal(scaled$Z, Z * 4)
  
  # Each functional part should be scaled
  expected_coef <- matrix(8, 5, 3)  # 2 * 4
  for (fd_scaled in scaled$functional_list) {
    testthat::expect_equal(
      unname(coef(fd_scaled)),
      unname(expected_coef)
    )
  }
})
```
### inprod.predictor_hybrid
The inner product of $f_1=(f_1^{(1)}, \ldots,f_1^{(K)}) $ and $f_2=(f_2^{(1)}, \ldots,f_2^{(K)})$ in $\mathcal{F}$ is defined as $\langle f_1, f_2\rangle_\mathcal{F} =  \sum_{k=1}^K \langle f_1^{(k)}, f_2^{(k)}\rangle_{L^2} = \sum_{k=1}^K \int_{\mathcal{T}_k} f_1^{(k)}(t_k) f_2^{(k)}(t_k) dt_k$ with norm $\Vert f_1 \Vert_\mathcal{F} = \langle f_1,f_1 \rangle_\mathcal{F}^{1/2} = \{ \sum_{k=1}^K \int_{\mathcal{T}_k} f_1^{(k)}(t_k)^2 dt_k\}^{1/2}$.  

Computes the inner product between two `predictor_hybrid` objects.Both scalar and functional components are included.

  We define the inner product between any two hybrid objects, $\mathbf{h}_1 = (f_1, \mathbf{v}_1)$ and $\mathbf{h}_2 = (f_2, \mathbf{v}_2)$, as
$$
    \langle \mathbf{h}_1, \mathbf{h}_2\rangle_{\mathcal{H}} = \langle f_1, f_2\rangle_\mathcal{F} + w \langle  \mathbf{v_1}, \mathbf{v_2} \rangle = \sum \limits_{k=1}^K \int_{\mathcal{T}_k} f_1^{(k)}(t_k) f_2^{(k)}(t_k) dt_k + \omega \sum \limits_{r=1}^p v_{1r}v_{2r}, 
$$
with norm $\Vert \cdot \Vert_\mathcal{H} = \langle \cdot,\cdot \rangle_\mathcal{H}^{1/2}$. $\omega$ is a positive weight that needs to be pre-specified or estimated. It is mainly used to take into account heterogeneity between functional and scalar parts in terms of measurement scale and/or amount of variation (see Section \ref{subsec: Data Preprocessing}). Without loss of generality and for the clarity of illustration, all the following theoretical results will be derived for $\omega=1$. The results remain valid for any positive weights.
- Usage

```r
inprod.predictor_hybrid(xi_1, xi_2)
```

- Arguments:

  - `xi_1`: A `predictor_hybrid` object.
  - `xi_2`: Another `predictor_hybrid` object.

- Value:  
A numeric matrix of inner products (or a scalar if both inputs are single observations).

- Details:  
  - Functional components are summed using `inprod()` from the `fda` package.  
  - Scalar components are handled via matrix multiplication.  
  - Returns a scalar if both `xi_1` and `xi_2` are single-sample predictors.
```{r}
#' Inner product between two predictor_hybrid objects (with broadcasting)
#'
#' Computes the inner product between two `predictor_hybrid` objects,
#' including both functional and scalar components. Supports broadcasting
#' when one of the inputs has a single observation. If only one input is given,
#' the inner product is computed with itself.
#'
#' @param xi_1 A `predictor_hybrid` object.
#' @param xi_2 Another `predictor_hybrid` object. If missing, defaults to `xi_1`.
#'
#' @return A numeric matrix of inner products (or a scalar if both inputs have one row).
#' @export
inprod.predictor_hybrid <- function(xi_1, xi_2 = NULL) {
  if (is.null(xi_2)) xi_2 <- xi_1
  
  # Optional: Check for basis compatibility
  # if (!is_same_basis(xi_1, xi_2)) stop("Functional predictors must share the same basis.")

  n1 <- xi_1$n_sample
  n2 <- xi_2$n_sample

  # Compute sum of pairwise functional inner products
  inprod_functional <- Reduce(`+`,
    Map(function(f1, f2) fda::inprod(f1, f2),
        xi_1$functional_list, xi_2$functional_list)
  )

  # Broadcast-aware scalar component
  Z1 <- if (n1 == 1) matrix(xi_1$Z, nrow = 1) else xi_1$Z
  Z2 <- if (n2 == 1) matrix(xi_2$Z, nrow = 1) else xi_2$Z
  inprod_scalar <- Z1 %*% t(Z2)

  result <- inprod_functional + inprod_scalar

  if (n1 == 1 && n2 == 1) as.numeric(result) else result
}

```

```{r}
testthat::test_that("inprod.predictor_hybrid works with broadcasting and self-inner product", {
  suppressPackageStartupMessages(library(fda))
  
  basis <- create.bspline.basis(c(0, 1), 5)
  coef_val <- function(val) matrix(val, 5, 3)

  # Define functional objects
  fd_1 <- fd(coef = coef_val(1), basisobj = basis)
  fd_2 <- fd(coef = coef_val(2), basisobj = basis)

  # Define scalar matrices
  Z1 <- matrix(c(1, 2), nrow = 1)         # 1 × 2
  Z2 <- matrix(c(3, 4), nrow = 1)         # 1 × 2
  Z_many <- matrix(rep(c(1, 2), 3), nrow = 3, byrow = TRUE)  # 3 × 2

  # (1, 1)
  x1 <- predictor_hybrid(Z1, list(fd_1, fd_1), list(matrix(0), matrix(0)), c(5, 5), 1, 2, 2)
  x2 <- predictor_hybrid(Z2, list(fd_2, fd_2), list(matrix(0), matrix(0)), c(5, 5), 1, 2, 2)
  val_scalar <- inprod.predictor_hybrid(x1, x2)

  testthat::expect_type(val_scalar, "double")
  testthat::expect_length(val_scalar, 1)

  # Expected functional inner product: 2 fds × sum(1 * 2) = 2 × (5×3) = 30
  expected_functional <- 2 * sum(1 * 2) * 15  # 5 × 3 = 15 elements
  expected_scalar <- sum(Z1 * Z2)            # 1*3 + 2*4 = 11
  testthat::expect_equal(val_scalar, expected_functional + expected_scalar)

  # (n, 1) broadcasting
  x3 <- predictor_hybrid(Z_many, list(fd_1, fd_1), list(matrix(0), matrix(0)), c(5, 5), 3, 2, 2)
  mat_3_1 <- inprod.predictor_hybrid(x3, x2)
  testthat::expect_equal(dim(mat_3_1), c(3, 1))
  testthat::expect_equal(as.numeric(mat_3_1), rep(val_scalar, 3))

  # (1, m) broadcasting
  x4 <- predictor_hybrid(Z_many, list(fd_2, fd_2), list(matrix(0), matrix(0)), c(5, 5), 3, 2, 2)
  mat_1_3 <- inprod.predictor_hybrid(x1, x4)
  testthat::expect_equal(dim(mat_1_3), c(1, 3))
  testthat::expect_equal(as.numeric(mat_1_3), rep(val_scalar, 3))

  # (n, m)
  mat_3_3 <- inprod.predictor_hybrid(x3, x4)
  testthat::expect_equal(dim(mat_3_3), c(3, 3))
  testthat::expect_true(all(as.numeric(mat_3_3) == val_scalar))

  # shorthand inprod(x) ≡ inprod(x, x)
  self_inner <- inprod.predictor_hybrid(x1)
  testthat::expect_equal(
    self_inner,
    inprod.predictor_hybrid(x1, x1)
  )
})

```


# helper functions

### is_same_basis
```{r}
#' @export
is_same_basis <- function(input, other) {
  all(
    length(input$functional_list) == length(other$functional_list),
    all(
      mapply(function(fd1, fd2) fda::is.eqbasis(fd1$basis, fd2$basis),
             input$functional_list, other$functional_list)
    )
  )
}
```


## Documenting the package and building

We finish by running commands that will document, build, and install the package.  It may also be a good idea to check the package from within this file.

```{r}
litr::document() # <-- use instead of devtools::document()
# devtools::build()
# devtools::install()
# devtools::check(document = FALSE)
```


