---
title: "Creating the ``r params$package_name`` R package"
author: "Your Name"
date: "The Date"
knit: litr::render
output: litr::litr_html_document
params:
  package_name: "FSHybridPLS" # <-- change this to your package name
  package_parent_dir: "." # <-- relative to this file's location
---

<!-- This Rmd file contains all the code needed to define an R package.  Press "Knit" in RStudio or more generally run `litr::render("name-of-this-file.Rmd")` to generate the R package.  Remember that when you want to modify anything about the R package, you should modify this document rather than the package that is outputted.
-->

## Package setup

We start by specifying the information needed in the DESCRIPTION file of the R package.

```{r package-setup, message=FALSE, results='hide'}
usethis::create_package(
  path = ".",
  fields = list(
    Package = params$package_name,
    Version = "0.0.0.9000",
    Title = "A Package That Says Hello",
    Description = "This package says hello.  But its actual purpose is to show how an R package can be completely coded in a single R markdown file.",
    Imports = "fda (>= 6.1.3)",
    `Authors@R` = person(
      given = "First",
      family = "Last",
      email = "you@gmail.com",
      role = c("aut", "cre")
      )
  )
)
usethis::use_mit_license(copyright_holder = "F. Last")
```

# Class predictor_hybrid
The `predictor_hybrid` class is an S3 object for representing hybrid predictors: a combination of scalar and functional covariates. The following code defines the class.

```{r}
#' Create a predictor_hybrid object (S3 version)
#'
#' Constructs a hybrid predictor object that stores both scalar and functional predictors,
#' along with Jacobians and metadata.
#'
#' @param Z A numeric matrix of dimension \code{n_sample Ã— n_scalar} representing scalar predictors.
#' @param functional_list A list of functional predictors (e.g., \code{fd} objects from the \code{fda} package).
#' @param jacobian_list A list of Jacobian matrices corresponding to the functional predictors.
#' @param n_basis_list A numeric vector indicating the number of basis functions for each functional predictor.
#' @param n_sample Number of observations (samples).
#' @param n_functional Number of functional predictors.
#' @param n_scalar Number of scalar predictors.
#'
#' @return A list of class \code{predictor_hybrid}.
#' @export
predictor_hybrid <- function(Z, functional_list, jacobian_list,
                             n_basis_list, n_sample, n_functional, n_scalar) {
  stopifnot(is.matrix(Z))
  stopifnot(length(functional_list) == n_functional)
  stopifnot(length(jacobian_list) == n_functional)
  stopifnot(length(n_basis_list) == n_functional)
  
  structure(
    list(
      Z = Z,
      functional_list = functional_list,
      jacobian_list = jacobian_list,
      n_basis_list = n_basis_list,
      n_sample = n_sample,
      n_functional = n_functional,
      n_scalar = n_scalar
    ),
    class = "predictor_hybrid"
  )
}
```



Let's write some tests to make sure the function behaves as desired:
```{r}
testthat::test_that("predictor_hybrid constructor works as expected (S3)", {
  Z <- matrix(rnorm(100 * 5), nrow = 100, ncol = 5)
  fd1 <- list(fdobj = "fd1 placeholder")
  fd2 <- list(fdobj = "fd2 placeholder")
  J1 <- matrix(runif(100), nrow = 10)
  J2 <- matrix(runif(200), nrow = 20)
  
  obj <- predictor_hybrid(
    Z = Z,
    functional_list = list(fd1, fd2),
    jacobian_list = list(J1, J2),
    n_basis_list = c(10, 20),
    n_sample = 100,
    n_functional = 2,
    n_scalar = 5
  )
  
  testthat::expect_s3_class(obj, "predictor_hybrid")
  testthat::expect_equal(nrow(obj$Z), 100)
  testthat::expect_equal(ncol(obj$Z), 5)
  testthat::expect_equal(length(obj$functional_list), 2)
  testthat::expect_equal(length(obj$jacobian_list), 2)
  testthat::expect_equal(obj$n_basis_list, c(10, 20))
  testthat::expect_equal(obj$n_sample, 100)
  testthat::expect_equal(obj$n_functional, 2)
  testthat::expect_equal(obj$n_scalar, 5)
})


```

## Basic arithmetic

### add.predictor_hybrid
Performs element-wise addition of two `predictor_hybrid` objects.  Functional predictors are combined using `plus.fd()` and `times.fd()` from the `fda` package.

- Usage

```r
add.predictor_hybrid(input, other, alpha = 1)
```

- Arguments:

  - `input`: A `predictor_hybrid` object.
  - `other`: Another `predictor_hybrid` object to be added.
  - `alpha`: A scalar multiplier applied to `other` before addition (default is 1).

- Value:
Returns a new `predictor_hybrid` object representing the result of the addition.

- Details: 
  - This function assumes both objects have the same number and structure of functional and scalar predictors.  
  - Functional parts are scaled by `alpha` using `times.fd()` and then summed using `plus.fd()`.  
  - Scalar predictors are added using standard matrix addition.

```{r}
#' Add two predictor_hybrid objects
#'
#' Performs element-wise addition of two predictor_hybrid objects.
#' Functional predictors are combined using `plus.fd()` and `times.fd()`.
#'
#' @param input A predictor_hybrid object.
#' @param other Another predictor_hybrid object.
#' @param alpha A numeric scalar multiplier for `other`.
#'
#' @return A new predictor_hybrid object representing the sum.
#' @export
add.predictor_hybrid <- function(input, other, alpha = 1) {
  if (input$n_functional != other$n_functional || input$n_scalar != other$n_scalar) {
    stop("Mismatch in number of predictors.")
  }
  
  # Optionally check that functional bases are the same
  # if (!is_same_basis(input, other)) stop("Different functional bases.")

  new_functional_list <- vector("list", input$n_functional)
  for (i in seq_len(input$n_functional)) {
    new_functional_list[[i]] <- plus.fd(
      input$functional_list[[i]],
      times.fd(alpha, other$functional_list[[i]])
    )
  }
  
  new_Z <- input$Z + alpha * other$Z
  
  predictor_hybrid(
    Z = new_Z,
    functional_list = new_functional_list,
    jacobian_list = input$jacobian_list,  # Assumes identical structure
    n_basis_list = input$n_basis_list,
    n_sample = input$n_sample,
    n_functional = input$n_functional,
    n_scalar = input$n_scalar
  )
}

```


```{r}
testthat::test_that("add.predictor_hybrid works for matching predictors", {
  suppressPackageStartupMessages(library(fda))

  Z1 <- matrix(1, nrow = 3, ncol = 2)
  Z2 <- matrix(2, nrow = 3, ncol = 2)
  
  basis <- fda::create.bspline.basis(c(0, 1), 5)
  fd1 <- fda::fd(coef = matrix(1, 5, 3), basisobj = basis)
  fd2 <- fda::fd(coef = matrix(2, 5, 3), basisobj = basis)
  
  obj1 <- predictor_hybrid(Z1, list(fd1), list(matrix(0)), c(5), 3, 1, 2)
  obj2 <- predictor_hybrid(Z2, list(fd2), list(matrix(0)), c(5), 3, 1, 2)
  
  obj3 <- add.predictor_hybrid(obj1, obj2, alpha = 1)
  
  testthat::expect_s3_class(obj3, "predictor_hybrid")
  testthat::expect_equal(obj3$Z, matrix(3, nrow = 3, ncol = 2))
  
  expected_coef <- matrix(3, 5, 3)
  testthat::expect_equal(
    unname(coef(obj3$functional_list[[1]])),
    unname(expected_coef)
  )
})


```
### subtr.predictor_hybrid
Performs element-wise subtraction of two `predictor_hybrid` objects.   Internally uses `add.predictor_hybrid(input, other, alpha = -1)` to compute the result by negating the second operand.

- Usage

```r
subtr.predictor_hybrid(input, other, alpha = 1)
```

- Arguments:

  - `input`: A `predictor_hybrid` object.
  - `other`: Another `predictor_hybrid` object to be subtracted.
  - `alpha`: A scalar multiplier applied to `other` before subtraction (default is 1).

- Value:  
Returns a new `predictor_hybrid` object representing the result of the subtraction.

- Details:  
  - This function assumes both objects have the same number and structure of functional and scalar predictors.  
  - It performs subtraction by internally calling `add.predictor_hybrid()` with `-alpha`.  
  - Functional parts are scaled using `times.fd()` and subtracted via `plus.fd()` with a negated factor.  
  - Scalar predictors are subtracted using standard matrix arithmetic.

```{r}
#' Subtract two predictor_hybrid objects
#'
#' Performs element-wise subtraction of two `predictor_hybrid` objects.
#' Internally uses `add.predictor_hybrid(input, other, alpha = -1)`.
#'
#' @param input A `predictor_hybrid` object.
#' @param other Another `predictor_hybrid` object to subtract.
#' @param alpha A scalar multiplier applied to `other` before subtraction (default is 1).
#'
#' @return A new `predictor_hybrid` object representing the result of subtraction.
#' @export
subtr.predictor_hybrid <- function(input, other, alpha = 1) {
  add.predictor_hybrid(input, other, alpha = -alpha)
}

```
We skip the unit test for this function.


### scalar_mul.predictor_hybrid
Multiplies all components of a `predictor_hybrid` object by a scalar. Functional components are scaled using `times.fd()` from the `fda` package, and scalar predictors are multiplied directly using matrix operations.

- Usage

```r
scalar_mul.predictor_hybrid(input, scalar)
```

- Arguments:

  - `input`: A `predictor_hybrid` object.
  - `scalar`: A numeric value used to scale both scalar and functional components.

- Value:  
Returns a new `predictor_hybrid` object with all components scaled by `scalar`.

- Details:  
  - Functional predictors are scaled using `times.fd(scalar, fd_obj)` for each element.  
  - Scalar predictors (the matrix `Z`) are scaled elementwise using matrix multiplication.

```{r}
#' Multiply a predictor_hybrid object by a scalar
#'
#' Performs scalar multiplication of both scalar and functional components 
#' of a `predictor_hybrid` object. Functional predictors are scaled using 
#' `times.fd()` from the `fda` package.
#'
#' @param input A `predictor_hybrid` object.
#' @param scalar A numeric value to multiply all components by.
#'
#' @return A new `predictor_hybrid` object scaled by `scalar`.
#' @export
scalar_mul.predictor_hybrid <- function(input, scalar) {
  new_functional_list <- lapply(
    input$functional_list,
    function(fd_obj) times.fd(scalar, fd_obj)
  )
  
  new_Z <- scalar * input$Z
  
  predictor_hybrid(
    Z = new_Z,
    functional_list = new_functional_list,
    jacobian_list = input$jacobian_list,
    n_basis_list = input$n_basis_list,
    n_sample = input$n_sample,
    n_functional = input$n_functional,
    n_scalar = input$n_scalar
  )
}
```

Here is a test code with two functional predictors:
```{r}
testthat::test_that("scalar_mul.predictor_hybrid works with two functional predictors", {
  suppressPackageStartupMessages(library(fda))
  
  # Scalar matrix
  Z <- matrix(2, nrow = 3, ncol = 2)
  
  # Create a shared basis for both functional predictors
  basis <- create.bspline.basis(c(0, 1), 5)
  
  # Two identical fd objects
  fd1 <- fd(coef = matrix(2, 5, 3), basisobj = basis)
  fd2 <- fd(coef = matrix(2, 5, 3), basisobj = basis)
  
  # Construct predictor_hybrid object
  obj <- predictor_hybrid(
    Z = Z,
    functional_list = list(fd1, fd2),
    jacobian_list = list(matrix(0), matrix(0)),
    n_basis_list = c(5, 5),
    n_sample = 3,
    n_functional = 2,
    n_scalar = 2
  )
  
  # Perform scalar multiplication
  scaled <- scalar_mul.predictor_hybrid(obj, 4)
  
  testthat::expect_s3_class(scaled, "predictor_hybrid")
  
  # Scalar part should be scaled
  testthat::expect_equal(scaled$Z, Z * 4)
  
  # Each functional part should be scaled
  expected_coef <- matrix(8, 5, 3)  # 2 * 4
  for (fd_scaled in scaled$functional_list) {
    testthat::expect_equal(
      unname(coef(fd_scaled)),
      unname(expected_coef)
    )
  }
})
```


## Documenting the package and building

We finish by running commands that will document, build, and install the package.  It may also be a good idea to check the package from within this file.

```{r}
litr::document() # <-- use instead of devtools::document()
# devtools::build()
# devtools::install()
# devtools::check(document = FALSE)
```


