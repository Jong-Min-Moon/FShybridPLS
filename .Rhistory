}
return (list(
rho = rho,
xi = xi,
W = W_now
))
}
lambda <- c(16,16)
res <- fit.hybridPLS(W,y,10, c(16, 16))
#' Compute V matrix (pre-corrected covariance estimator)
#'
#' Constructs the V matrix involving inner products of functional predictors
#' (weighted by their Gram matrices) and scalar predictors against response y.
#'
#' @param W A `predictor_hybrid` object.
#' @param y A numeric response vector of length equal to number of samples.
#'
#' @return A matrix representing the corrected cross-covariance structure.
#' @export
get_pre_corrcov <- function(W, y){
n <- W$n_sample
K <- W$n_functional
# building blocks
## C_J : C multiplied by J. Scalable to arbitrary K
C_J <- get_CJ(W)
## covariance
J_Ct_y <- t(C_J) %*% y
Zt_y <- t(W$Z) %*% y
# V matrix
upper_left <- J_Ct_y %*% t(J_Ct_y)
upper_right <- J_Ct_y %*% t(Zt_y)
lower_left <- t(upper_right)
lower_right <- Zt_y %*% t(Zt_y)
V_star <- cbind(
rbind(upper_left, lower_left),
rbind(upper_right, lower_right)
)/(n^2)
return(V_star)
}
#' Compute the First PLS Component from a Hybrid Predictor
#'
#' Computes the coefficients of the first Partial Least Squares (PLS) component based on
#' a hybrid predictor object and a response vector, using a regularized generalized eigenvalue problem.
#'
#' @param W A predictor_hybrid object containing both functional and scalar predictors.
#' @param y A numeric response vector of length equal to the number of samples in W.
#' @param L cholesky decompisition of a regularization matrix (typically positive definite) used in the generalized eigenproblem.
#'
#' @return A list with the following elements:
#'
#'   xi_hat: The estimated first PLS component as a predictor_hybrid object.
#'   E: The generalized eigenvalue problem matrix E = inv(L) V* t(inv(L)).
#'   V_star: The cross-covariance matrix between predictors and response.}
#'   eigen_val: The leading eigenvalue of E.
#'
#'
#' @export
get_pls_comp <- function(W, y, L){
V_star <- get_pre_corrcov(W, y)
#invL <- Matrix::chol2inv(L)
invL <- solve(L)
A <- V_star %*% t(invL)       # A = V* × t(inv(L))
E <- invL %*% A               # E = inv(L) × A
eigen_result <- eigen(E)
e <- eigen_result$vectors[, 1]
if (is.complex(e)){
print("stop")
return("stop")
}
xi_star <- t(invL) %*% e      # xi_star solves t(L) xi = e
xi_hat <- predictor_hybrid_from_coef(format = W, coef = xi_star)
return(xi_hat)
}
#' @export
fit.hybridPLS <- function(W, y, n_iter, lambda) {
# 1. Initialize storage
W_now <- rho <- xi <- delta <- nu  <- sigma <- eta <- list()
# 3. Initialize residuals
W_now[[1]] <- W
y_now <- y
final_succesful_iteration <- 0
constr_mat <- get_constraint_matrix_hybrid(W, lambda)
constr_mat_chol <- t(chol(constr_mat))
for (l in 1:n_iter) {
cat(paste(l, "th component", "\n"))
#xi[[l]]  <- get_xi_hat_linear_pen(W_now[[l]], y_now, lambda) # PLS direction
xi[[l]]  <- get_pls_comp(W_now[[l]], y_now, constr_mat_chol) # PLS direction
print(xi[[l]])
rho[[l]] <- inprod.predictor_hybrid(W_now[[l]], xi[[l]]) #PLS score
delta[[l]] <- get_delta(W_now[[l]], rho[[l]]);
W_now[[l + 1]] <- residualize_predictor(W_now[[l]], rho[[l]], delta[[l]]) # predictor residual
nu[[l]] <- get_nu(y_now, rho[[l]]); y_now <- residualize_y(y_now, rho[[l]], nu[[l]]) # response residual
# Step 3: Orthogonalize and update prediction
#sigma[[l]] <- xi[[l]]
#if (l == 1) {
#  eta[[l]] <- scalar_mul(sigma[[l]], nu[[l]])
#} else {
#  for (u in 1:(l - 1)) {
#    sigma[[l]] <- subtr(sigma[[l]], sigma[[u]], hybrid_inner_prod(delta[[u]], xi[[l]]))
#  }
#  eta[[l]] <- add(eta[[l - 1]], sigma[[l]], nu[[l]])
#}
}
return (list(
rho = rho,
xi = xi,
W = W_now
))
}
lambda <- c(16,16)
res <- fit.hybridPLS(W,y,10, c(16, 16))
lambda <- c(16,16)
res <- fit.hybridPLS(W,y,4, c(16, 16))
inprod_pen.predictor_hybrid(res$xi[[1]], res$xi[[10]], lambda)
inprod_pen.predictor_hybrid(res$xi[[1]], res$xi[[4]], lambda)
inprod_pen.predictor_hybrid(res$xi[[1]], res$xi[[4]], 10*lambda)
inprod_pen.predictor_hybrid(res$xi[[1]], res$xi[[4]], lambda/10)
sum(y * inprod.predictor_hybrid(res$W[[4]], res$xi[[1]]))
inprod_pen.predictor_hybrid(res$xi[[4]], res$xi[[4]], lambda)
inprod_pen.predictor_hybrid(res$xi[[4]], res$xi[[4]], lambda/10)
inprod_pen.predictor_hybrid(res$xi[[4]], res$xi[[4]], 10*lambda )
inprod_pen.predictor_hybrid(res$xi[[3]], res$xi[[4]], lambda)
inprod_pen.predictor_hybrid(res$xi[[3]], res$xi[[4]], 10*lambda)
inprod_pen.predictor_hybrid(res$xi[[3]], res$xi[[4]], lambda/10)
#' @export
fit.hybridPLS <- function(W, y, n_iter, lambda) {
# 1. Initialize storage
W_now <- rho <- xi <- delta <- nu  <- sigma <- eta <- list()
# 3. Initialize residuals
W_now[[1]] <- W
y_now <- y
final_succesful_iteration <- 0
constr_mat <- get_constraint_matrix_hybrid(W, lambda)
constr_mat_chol <- t(chol(constr_mat))
for (l in 1:n_iter) {
cat(paste(l, "th component", "\n"))
xi[[l]]  <- get_xi_hat_linear_pen(W_now[[l]], y_now, lambda) # PLS direction
#xi[[l]]  <- get_pls_comp(W_now[[l]], y_now, constr_mat_chol) # PLS direction
print(xi[[l]])
rho[[l]] <- inprod.predictor_hybrid(W_now[[l]], xi[[l]]) #PLS score
delta[[l]] <- get_delta(W_now[[l]], rho[[l]]);
W_now[[l + 1]] <- residualize_predictor(W_now[[l]], rho[[l]], delta[[l]]) # predictor residual
nu[[l]] <- get_nu(y_now, rho[[l]]); y_now <- residualize_y(y_now, rho[[l]], nu[[l]]) # response residual
# Step 3: Orthogonalize and update prediction
#sigma[[l]] <- xi[[l]]
#if (l == 1) {
#  eta[[l]] <- scalar_mul(sigma[[l]], nu[[l]])
#} else {
#  for (u in 1:(l - 1)) {
#    sigma[[l]] <- subtr(sigma[[l]], sigma[[u]], hybrid_inner_prod(delta[[u]], xi[[l]]))
#  }
#  eta[[l]] <- add(eta[[l - 1]], sigma[[l]], nu[[l]])
#}
}
return (list(
rho = rho,
xi = xi,
W = W_now
))
}
lambda <- c(16,16)
res <- fit.hybridPLS(W,y,4, c(16, 16))
inprod_pen.predictor_hybrid(res$xi[[1]], res$xi[[4]], lambda)
inprod_pen.predictor_hybrid(res$xi[[1]], res$xi[[4]], 10*lambda)
inprod_pen.predictor_hybrid(res$xi[[1]], res$xi[[4]], lambda/10)
sum(y * inprod.predictor_hybrid(res$W[[4]], res$xi[[1]]))
inprod_pen.predictor_hybrid(res$xi[[3]], res$xi[[4]], lambda)
inprod_pen.predictor_hybrid(res$xi[[3]], res$xi[[4]], 10*lambda)
inprod_pen.predictor_hybrid(res$xi[[3]], res$xi[[4]], lambda/10)
sum(y * inprod.predictor_hybrid(res$W[[3]], res$xi[[1]]))
inprod_pen.predictor_hybrid(res$xi[[5]], res$xi[[10]], lambda)
inprod_pen.predictor_hybrid(res$xi[[4]], res$xi[[4]], lambda)
inprod_pen.predictor_hybrid(res$xi[[4]], res$xi[[4]], lambda/10)
inprod_pen.predictor_hybrid(res$xi[[4]], res$xi[[4]], 10*lambda )
#' @export
fit.hybridPLS_eigen <- function(W, y, n_iter, lambda) {
# 1. Initialize storage
W_now <- rho <- xi <- delta <- nu  <- sigma <- eta <- list()
# 3. Initialize residuals
W_now[[1]] <- W
y_now <- y
final_succesful_iteration <- 0
constr_mat <- get_constraint_matrix_hybrid(W, lambda)
constr_mat_chol <- t(chol(constr_mat))
for (l in 1:n_iter) {
cat(paste(l, "th component", "\n"))
#xi[[l]]  <- get_xi_hat_linear_pen(W_now[[l]], y_now, lambda) # PLS direction
xi[[l]]  <- get_pls_comp(W_now[[l]], y_now, constr_mat_chol) # PLS direction
rho[[l]] <- inprod.predictor_hybrid(W_now[[l]], xi[[l]]) #PLS score
delta[[l]] <- get_delta(W_now[[l]], rho[[l]]);
W_now[[l + 1]] <- residualize_predictor(W_now[[l]], rho[[l]], delta[[l]]) # predictor residual
nu[[l]] <- get_nu(y_now, rho[[l]]); y_now <- residualize_y(y_now, rho[[l]], nu[[l]]) # response residual
# Step 3: Orthogonalize and update prediction
#sigma[[l]] <- xi[[l]]
#if (l == 1) {
#  eta[[l]] <- scalar_mul(sigma[[l]], nu[[l]])
#} else {
#  for (u in 1:(l - 1)) {
#    sigma[[l]] <- subtr(sigma[[l]], sigma[[u]], hybrid_inner_prod(delta[[u]], xi[[l]]))
#  }
#  eta[[l]] <- add(eta[[l - 1]], sigma[[l]], nu[[l]])
#}
}
return (list(
rho = rho,
xi = xi,
W = W_now
))
}
res_eigen <- fit.hybridPLS_eigen(W,y,4, lambda)
inprod_pen.predictor_hybrid(res_eigen$xi[[1]], res_eigen$xi[[4]], lambda)
inprod_pen.predictor_hybrid(res$xi[[1]], res$xi[[4]], lambda)
inprod_pen.predictor_hybrid(res_eigen$xi[[1]], res_eigen$xi[[4]], lambda)
inprod_pen.predictor_hybrid(res$xi[[1]], res$xi[[4]], lambda)
inprod_pen.predictor_hybrid(res$xi[[1]], res$xi[[4]], lambda)
inprod_pen.predictor_hybrid(res$xi[[1]], res$xi[[4]], 10*lambda)
inprod_pen.predictor_hybrid(res$xi[[1]], res$xi[[4]], lambda/10)
sum(y * inprod.predictor_hybrid(res$W[[4]], res$xi[[1]]))
inprod_pen.predictor_hybrid(res$xi[[1]], res$xi[[4]], lambda) - inprod_pen.predictor_hybrid(res_eigen$xi[[1]], res_eigen$xi[[4]], lambda)
inprod_pen.predictor_hybrid(res$xi[[1]], res$xi[[4]], 10*lambda) - inprod_pen.predictor_hybrid(res_eigen$xi[[1]], res_eigen$xi[[4]], 10*lambda)
inprod_pen.predictor_hybrid(res$xi[[1]], res$xi[[4]], lambda/10) - inprod_pen.predictor_hybrid(res_eigen$xi[[1]], res_eigen$xi[[4]], lambda/10)
sum(y * inprod.predictor_hybrid(res$W[[4]], res$xi[[1]])) - sum(y * inprod.predictor_hybrid(res_eigen$W[[4]], res_eigen$xi[[1]]))
inprod_pen.predictor_hybrid(res$xi[[3]], res$xi[[4]], lambda)
inprod_pen.predictor_hybrid(res$xi[[3]], res$xi[[4]], lambda) - inprod_pen.predictor_hybrid(res_eigen$xi[[3]], res_eigen$xi[[4]], lambda)
inprod_pen.predictor_hybrid(res$xi[[3]], res$xi[[4]], 10*lambda) - inprod_pen.predictor_hybrid(res_eigen$xi[[3]], res_eigen$xi[[4]], 10*lambda)
lambda <- c(0.5,0.5)
L=8
res_eigen <- fit.hybridPLS_eigen(W,y,L, lambda)
res <- fit.hybridPLS(W,y,L, lambda)
#' @export
fit.hybridPLS <- function(W, y, n_iter, lambda) {
# 1. Initialize storage
W_now <- rho <- xi <- delta <- nu  <- sigma <- eta <- list()
# 3. Initialize residuals
W_now[[1]] <- W
y_now <- y
final_succesful_iteration <- 0
constr_mat <- get_constraint_matrix_hybrid(W, lambda)
constr_mat_chol <- t(chol(constr_mat))
for (l in 1:n_iter) {
cat(paste(l, "th component", "\n"))
xi[[l]]  <- get_xi_hat_linear_pen(W_now[[l]], y_now, lambda) # PLS direction
rho[[l]] <- inprod.predictor_hybrid(W_now[[l]], xi[[l]]) #PLS score
delta[[l]] <- get_delta(W_now[[l]], rho[[l]]);
W_now[[l + 1]] <- residualize_predictor(W_now[[l]], rho[[l]], delta[[l]]) # predictor residual
nu[[l]] <- get_nu(y_now, rho[[l]]); y_now <- residualize_y(y_now, rho[[l]], nu[[l]]) # response residual
# Step 3: Orthogonalize and update prediction
#sigma[[l]] <- xi[[l]]
#if (l == 1) {
#  eta[[l]] <- scalar_mul(sigma[[l]], nu[[l]])
#} else {
#  for (u in 1:(l - 1)) {
#    sigma[[l]] <- subtr(sigma[[l]], sigma[[u]], hybrid_inner_prod(delta[[u]], xi[[l]]))
#  }
#  eta[[l]] <- add(eta[[l - 1]], sigma[[l]], nu[[l]])
#}
}
return (list(
rho = rho,
xi = xi,
W = W_now
))
}
res <- fit.hybridPLS(W,y,L, lambda)
inprod_pen.predictor_hybrid(res$xi[[1]], res$xi[[4]], lambda) - inprod_pen.predictor_hybrid(res_eigen$xi[[1]], res_eigen$xi[[4]], lambda)
inprod_pen.predictor_hybrid(res$xi[[1]], res$xi[[4]], 10*lambda) - inprod_pen.predictor_hybrid(res_eigen$xi[[1]], res_eigen$xi[[4]], 10*lambda)
inprod_pen.predictor_hybrid(res$xi[[1]], res$xi[[4]], lambda/10) - inprod_pen.predictor_hybrid(res_eigen$xi[[1]], res_eigen$xi[[4]], lambda/10)
sum(y * inprod.predictor_hybrid(res$W[[4]], res$xi[[1]])) - sum(y * inprod.predictor_hybrid(res_eigen$W[[4]], res_eigen$xi[[1]]))
inprod_pen.predictor_hybrid(res$xi[[3]], res$xi[[4]], lambda) - inprod_pen.predictor_hybrid(res_eigen$xi[[3]], res_eigen$xi[[4]], lambda)
inprod_pen.predictor_hybrid(res$xi[[3]], res$xi[[4]], 10*lambda) - inprod_pen.predictor_hybrid(res_eigen$xi[[3]], res_eigen$xi[[4]], 10*lambda)
inprod_pen.predictor_hybrid(res$xi[[3]], res$xi[[4]], lambda/10)
sum(y * inprod.predictor_hybrid(res$W[[3]], res$xi[[1]]))
inprod_pen.predictor_hybrid(res$xi[[1]], res$xi[[8]], lambda) - inprod_pen.predictor_hybrid(res_eigen$xi[[1]], res_eigen$xi[[8]], lambda)
inprod_pen.predictor_hybrid(res$xi[[1]], res$xi[[8]], 10*lambda) - inprod_pen.predictor_hybrid(res_eigen$xi[[1]], res_eigen$xi[[8]], 10*lambda)
inprod_pen.predictor_hybrid(res$xi[[1]], res$xi[[8]], lambda/10) - inprod_pen.predictor_hybrid(res_eigen$xi[[1]], res_eigen$xi[[8]], lambda/10)
sum(y * inprod.predictor_hybrid(res$W[[8]], res$xi[[1]])) - sum(y * inprod.predictor_hybrid(res_eigen$W[[8]], res_eigen$xi[[1]]))
sum(y * inprod.predictor_hybrid(res$W[[8]], res$xi[[1]]))
sum(y * inprod.predictor_hybrid(res_eigen$W[[8]], res_eigen$xi[[1]]))
#' @export
fit.hybridPLS <- function(W, y, n_iter, lambda) {
# 1. Initialize storage
W_now <- rho <- xi <- delta <- nu  <- iota <- beta <- list()
# 3. Initialize residuals
W_now[[1]] <- W
y_now <- y
final_succesful_iteration <- 0
constr_mat <- get_constraint_matrix_hybrid(W, lambda)
constr_mat_chol <- t(chol(constr_mat))
for (l in 1:n_iter) {
cat(paste(l, "th component", "\n"))
xi[[l]]  <- get_xi_hat_linear_pen(W_now[[l]], y_now, lambda) # PLS direction
rho[[l]] <- inprod.predictor_hybrid(W_now[[l]], xi[[l]]) #PLS score
delta[[l]] <- get_delta(W_now[[l]], rho[[l]]);
W_now[[l + 1]] <- residualize_predictor(W_now[[l]], rho[[l]], delta[[l]]) # predictor residual
nu[[l]] <- get_nu(y_now, rho[[l]]); y_now <- residualize_y(y_now, rho[[l]], nu[[l]]) # response residual
iota[[l]] <- xi[[l]]
if (l == 1) {
beta[[l]] <- scalar_mul.predictor_hybrid( iota[[l]], nu[[l]] )
} else {
for (u in 1:(l - 1)) {
iota[[l]] <- subtr.predictor_hybrid( iota[[l]], iota[[u]], inprod.predictor_hybrid(delta[[u]], xi[[l]]))
}
beta[[l]] <- add.predictor_hybrid(beta[[l - 1]], iota[[l]], nu[[l]])
#}
}
return (list(
rho = rho,
xi = xi,
W = W_now
beta = beta
))
}
#' @export
fit.hybridPLS <- function(W, y, n_iter, lambda) {
# 1. Initialize storage
W_now <- rho <- xi <- delta <- nu  <- iota <- beta <- list()
# 3. Initialize residuals
W_now[[1]] <- W
y_now <- y
final_succesful_iteration <- 0
constr_mat <- get_constraint_matrix_hybrid(W, lambda)
constr_mat_chol <- t(chol(constr_mat))
for (l in 1:n_iter) {
cat(paste(l, "th component", "\n"))
xi[[l]]  <- get_xi_hat_linear_pen(W_now[[l]], y_now, lambda) # PLS direction
rho[[l]] <- inprod.predictor_hybrid(W_now[[l]], xi[[l]]) #PLS score
delta[[l]] <- get_delta(W_now[[l]], rho[[l]]);
W_now[[l + 1]] <- residualize_predictor(W_now[[l]], rho[[l]], delta[[l]]) # predictor residual
nu[[l]] <- get_nu(y_now, rho[[l]]); y_now <- residualize_y(y_now, rho[[l]], nu[[l]]) # response residual
iota[[l]] <- xi[[l]]
if (l == 1) {
beta[[l]] <- scalar_mul.predictor_hybrid( iota[[l]], nu[[l]] )
} else {
for (u in 1:(l - 1)) {
iota[[l]] <- subtr.predictor_hybrid( iota[[l]], iota[[u]], inprod.predictor_hybrid(delta[[u]], xi[[l]]))
}
beta[[l]] <- add.predictor_hybrid(beta[[l - 1]], iota[[l]], nu[[l]])
}
}
return (list(
rho = rho,
xi = xi,
W = W_now
beta = beta
))
}
#' @export
fit.hybridPLS <- function(W, y, n_iter, lambda) {
# 1. Initialize storage
W_now <- rho <- xi <- delta <- nu  <- iota <- beta <- list()
# 3. Initialize residuals
W_now[[1]] <- W
y_now <- y
final_succesful_iteration <- 0
constr_mat <- get_constraint_matrix_hybrid(W, lambda)
constr_mat_chol <- t(chol(constr_mat))
for (l in 1:n_iter) {
cat(paste(l, "th component", "\n"))
xi[[l]]  <- get_xi_hat_linear_pen(W_now[[l]], y_now, lambda) # PLS direction
rho[[l]] <- inprod.predictor_hybrid(W_now[[l]], xi[[l]]) #PLS score
delta[[l]] <- get_delta(W_now[[l]], rho[[l]]);
W_now[[l + 1]] <- residualize_predictor(W_now[[l]], rho[[l]], delta[[l]]) # predictor residual
nu[[l]] <- get_nu(y_now, rho[[l]]); y_now <- residualize_y(y_now, rho[[l]], nu[[l]]) # response residual
iota[[l]] <- xi[[l]]
if (l == 1) {
beta[[l]] <- scalar_mul.predictor_hybrid( iota[[l]], nu[[l]] )
} else {
for (u in 1:(l - 1)) {
iota[[l]] <- subtr.predictor_hybrid( iota[[l]], iota[[u]], inprod.predictor_hybrid(delta[[u]], xi[[l]]))
}
beta[[l]] <- add.predictor_hybrid(beta[[l - 1]], iota[[l]], nu[[l]])
}
}
return (list(
rho = rho,
xi = xi,
W = W_now
beta = beta
))
}
#' @export
fit.hybridPLS <- function(W, y, n_iter, lambda) {
# 1. Initialize storage
W_now <- rho <- xi <- delta <- nu  <- iota <- beta <- list()
# 3. Initialize residuals
W_now[[1]] <- W
y_now <- y
final_succesful_iteration <- 0
constr_mat <- get_constraint_matrix_hybrid(W, lambda)
constr_mat_chol <- t(chol(constr_mat))
for (l in 1:n_iter) {
cat(paste(l, "th component", "\n"))
xi[[l]]  <- get_xi_hat_linear_pen(W_now[[l]], y_now, lambda) # PLS direction
rho[[l]] <- inprod.predictor_hybrid(W_now[[l]], xi[[l]]) #PLS score
delta[[l]] <- get_delta(W_now[[l]], rho[[l]]);
W_now[[l + 1]] <- residualize_predictor(W_now[[l]], rho[[l]], delta[[l]]) # predictor residual
nu[[l]] <- get_nu(y_now, rho[[l]]); y_now <- residualize_y(y_now, rho[[l]], nu[[l]]) # response residual
iota[[l]] <- xi[[l]]
if (l == 1) {
beta[[l]] <- scalar_mul.predictor_hybrid( iota[[l]], nu[[l]] )
} else {
for (u in 1:(l - 1)) iota[[l]] <- subtr.predictor_hybrid( iota[[l]], iota[[u]], inprod.predictor_hybrid(delta[[u]], xi[[l]]))
beta[[l]] <- add.predictor_hybrid(beta[[l - 1]], iota[[l]], nu[[l]])
}
}
return (list(
rho = rho,
xi = xi,
W = W_now
beta = beta
))
}
#' @export
fit.hybridPLS <- function(W, y, n_iter, lambda) {
# 1. Initialize storage
W_now <- rho <- xi <- delta <- nu  <- iota <- beta <- list()
# 3. Initialize residuals
W_now[[1]] <- W
y_now <- y
final_succesful_iteration <- 0
constr_mat <- get_constraint_matrix_hybrid(W, lambda)
constr_mat_chol <- t(chol(constr_mat))
for (l in 1:n_iter) {
cat(paste(l, "th component", "\n"))
xi[[l]]  <- get_xi_hat_linear_pen(W_now[[l]], y_now, lambda) # PLS direction
rho[[l]] <- inprod.predictor_hybrid(W_now[[l]], xi[[l]]) #PLS score
delta[[l]] <- get_delta(W_now[[l]], rho[[l]]);
W_now[[l + 1]] <- residualize_predictor(W_now[[l]], rho[[l]], delta[[l]]) # predictor residual
nu[[l]] <- get_nu(y_now, rho[[l]]); y_now <- residualize_y(y_now, rho[[l]], nu[[l]]) # response residual
iota[[l]] <- xi[[l]]
if (l == 1) {
beta[[l]] <- scalar_mul.predictor_hybrid( iota[[l]], nu[[l]] )
} else {
for (u in 1:(l - 1)) iota[[l]] <- subtr.predictor_hybrid( iota[[l]], iota[[u]], inprod.predictor_hybrid(delta[[u]], xi[[l]]))
beta[[l]] <- add.predictor_hybrid(beta[[l - 1]], iota[[l]], nu[[l]])
}
}
return (list(
rho = rho,
xi = xi,
W = W_now
beta = beta
))
}
#' @export
fit.hybridPLS <- function(W, y, n_iter, lambda) {
# 1. Initialize storage
W_now <- rho <- xi <- delta <- nu  <- iota <- beta <- list()
# 3. Initialize residuals
W_now[[1]] <- W
y_now <- y
final_succesful_iteration <- 0
constr_mat <- get_constraint_matrix_hybrid(W, lambda)
constr_mat_chol <- t(chol(constr_mat))
for (l in 1:n_iter) {
cat(paste(l, "th component", "\n"))
xi[[l]]  <- get_xi_hat_linear_pen(W_now[[l]], y_now, lambda) # PLS direction
rho[[l]] <- inprod.predictor_hybrid(W_now[[l]], xi[[l]]) #PLS score
delta[[l]] <- get_delta(W_now[[l]], rho[[l]]);
W_now[[l + 1]] <- residualize_predictor(W_now[[l]], rho[[l]], delta[[l]]) # predictor residual
nu[[l]] <- get_nu(y_now, rho[[l]]); y_now <- residualize_y(y_now, rho[[l]], nu[[l]]) # response residual
iota[[l]] <- xi[[l]]
if (l == 1) {
beta[[l]] <- scalar_mul.predictor_hybrid( iota[[l]], nu[[l]] )
} else {
for (u in 1:(l - 1)) iota[[l]] <- subtr.predictor_hybrid( iota[[l]], iota[[u]], inprod.predictor_hybrid(delta[[u]], xi[[l]]))
beta[[l]] <- add.predictor_hybrid(beta[[l - 1]], iota[[l]], nu[[l]])
}
}
return (list(
rho = rho,
xi = xi,
W = W_now
beta = beta
))
}
#' @export
fit.hybridPLS <- function(W, y, n_iter, lambda) {
# 1. Initialize storage
W_now <- rho <- xi <- delta <- nu  <- iota <- beta <- list()
# 3. Initialize residuals
W_now[[1]] <- W
y_now <- y
final_succesful_iteration <- 0
constr_mat <- get_constraint_matrix_hybrid(W, lambda)
constr_mat_chol <- t(chol(constr_mat))
for (l in 1:n_iter) {
cat(paste(l, "th component", "\n"))
xi[[l]]  <- get_xi_hat_linear_pen(W_now[[l]], y_now, lambda) # PLS direction
rho[[l]] <- inprod.predictor_hybrid(W_now[[l]], xi[[l]]) #PLS score
delta[[l]] <- get_delta(W_now[[l]], rho[[l]]);
W_now[[l + 1]] <- residualize_predictor(W_now[[l]], rho[[l]], delta[[l]]) # predictor residual
nu[[l]] <- get_nu(y_now, rho[[l]]); y_now <- residualize_y(y_now, rho[[l]], nu[[l]]) # response residual
iota[[l]] <- xi[[l]]
if (l == 1) {
beta[[l]] <- scalar_mul.predictor_hybrid( iota[[l]], nu[[l]] )
} else {
for (u in 1:(l - 1)) iota[[l]] <- subtr.predictor_hybrid( iota[[l]], iota[[u]], inprod.predictor_hybrid(delta[[u]], xi[[l]]))
beta[[l]] <- add.predictor_hybrid(beta[[l - 1]], iota[[l]], nu[[l]])
}
}
return (list(
rho = rho,
xi = xi,
W = W_now,
beta = beta
))
}
lambda <- c(0.5,0.5)
L=8
res <- fit.hybridPLS(W,y,L, lambda)
res_eigen <- fit.hybridPLS_eigen(W,y,L, lambda)
