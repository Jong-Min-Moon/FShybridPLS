result2 <- add.predictor_hybrid(x3, x1, alpha = 1)
testthat::expect_equal(result2$Z, expected_Z)
for (fd_out in result2$functional_list) {
testthat::expect_equal(unname(coef(fd_out)), matrix(4, nrow = 5, ncol = 3))
}
# Incompatible sample sizes (should fail)
x_bad <- predictor_hybrid(matrix(1, 2, 2), fd_list(1, 2))
testthat::expect_error(add.predictor_hybrid(x3, x_bad), "incompatible for broadcasting")
# Incompatible functional basis (should fail)
bad_basis <- create.bspline.basis(c(0, 1), nbasis = 6)
bad_fd <- fd_list(2, 3, bad_basis)
x_basis_mismatch <- predictor_hybrid(Z3, bad_fd)
testthat::expect_error(add.predictor_hybrid(x3, x_basis_mismatch), "same basis")
})
add.predictor_hybrid <- function(xi_1, xi_2, alpha = 1) {
# Safe access to is.eqbasis()
is_eqbasis <- getFromNamespace("is.eqbasis", "fda")
for (i in seq_len(xi_1$n_functional)) {
if (!is_eqbasis(xi_1$functional_list[[i]]$basis, xi_2$functional_list[[i]]$basis)) {
stop("Functional predictors must have the same basis.")
}
}
# Type checks
if (!inherits(xi_1, "predictor_hybrid") || !inherits(xi_2, "predictor_hybrid")) {
stop("Both inputs must be of class 'predictor_hybrid'.")
}
# Structural checks
if (xi_1$n_functional != xi_2$n_functional) {
stop("Mismatch in number of functional predictors.")
}
if (xi_1$n_scalar != xi_2$n_scalar) {
stop("Mismatch in number of scalar predictors.")
}
# Swap so that broadcasting always applies to xi_2
if (xi_1$n_sample == 1 && xi_2$n_sample > 1) {
tmp <- xi_1
xi_1 <- xi_2
xi_2 <- tmp
}
n1 <- xi_1$n_sample
n2 <- xi_2$n_sample
if (!(n1 == n2 || n2 == 1)) {
stop("Sample sizes are incompatible for broadcasting.")
}
# Prepare components
f1 <- xi_1$functional_list
f2 <- xi_2$functional_list
Z1 <- xi_1$Z
Z2 <- xi_2$Z
# Replicate fd and Z if needed
if (n2 == 1) {
f2 <- rep_fd(f2, n1)
Z2 <- matrix(rep(c(Z2), n1), nrow = n1, byrow = TRUE)
}
# Combine functional predictors
new_functional_list <- Map(
function(f1, f2) plus.fd(f1, times.fd(alpha, f2)),
f1,
f2
)
# Compute scalar inner products
inprod_scalar <- rowSums(Z1 * Z2)
# Combine scalar predictors
new_Z <- Z1 + alpha * Z2
# Construct new object
predictor_hybrid(Z = new_Z, functional_list = new_functional_list)
}
testthat::test_that("add.predictor_hybrid handles broadcasting and basis compatibility", {
suppressPackageStartupMessages(library(fda))
# Create shared B-spline basis
basis <- create.bspline.basis(c(0, 1), nbasis = 5)
# Helper to generate a valid coefficient matrix
coef_mat <- function(val, n_sample, basis_obj) {
nbasis <- basis_obj$nbasis
matrix(val, nrow = nbasis, ncol = n_sample)
}
# Helper to create a list of fd objects (2 functional predictors)
fd_list <- function(val, n_sample, basis_obj = basis) {
list(
fd(coef = coef_mat(val, n_sample, basis_obj), basisobj = basis_obj),
fd(coef = coef_mat(val, n_sample, basis_obj), basisobj = basis_obj)
)
}
# Scalar predictors
Z1 <- matrix(1, nrow = 1, ncol = 2)
Z3 <- matrix(3, nrow = 3, ncol = 2)
# Functional predictors (same basis)
F1 <- fd_list(1, 1)
F3 <- fd_list(3, 3)
# Create predictor_hybrid objects
x1 <- predictor_hybrid(Z1, F1)  # 1 sample
x3 <- predictor_hybrid(Z3, F3)  # 3 samples
# Broadcast x1 to match x3
result <- add.predictor_hybrid(x1, x3, alpha = 1)
# Check metadata
testthat::expect_s3_class(result, "predictor_hybrid")
testthat::expect_equal(result$n_sample, 3)
testthat::expect_equal(result$n_scalar, 2)
testthat::expect_equal(result$n_functional, 2)
# Check scalar component
expected_Z <- matrix(4, nrow = 3, ncol = 2)  # 1 + 3 = 4
testthat::expect_equal(result$Z, expected_Z)
# Check functional component
for (fd_out in result$functional_list) {
testthat::expect_equal(unname(coef(fd_out)), matrix(4, nrow = 5, ncol = 3))
}
# Test symmetry: broadcasting x3 + x1
result2 <- add.predictor_hybrid(x3, x1, alpha = 1)
testthat::expect_equal(result2$Z, expected_Z)
for (fd_out in result2$functional_list) {
testthat::expect_equal(unname(coef(fd_out)), matrix(4, nrow = 5, ncol = 3))
}
# Incompatible sample sizes (should fail)
x_bad <- predictor_hybrid(matrix(1, 2, 2), fd_list(1, 2))
testthat::expect_error(add.predictor_hybrid(x3, x_bad), "incompatible for broadcasting")
# Incompatible functional basis (should fail)
bad_basis <- create.bspline.basis(c(0, 1), nbasis = 6)
bad_fd <- fd_list(2, 3, bad_basis)
x_basis_mismatch <- predictor_hybrid(Z3, bad_fd)
testthat::expect_error(add.predictor_hybrid(x3, x_basis_mismatch), "same basis")
})
nipals_pen_hybrid <- function(W, y, n_iter, lambda, verbose) {
# 1. initialize the storage
rho <- xi <- delta <- nu  <- sigma <- eta <- list()
E <- V_star <- eigen_val <-list()
fitted_value_W <- fitted_value_y <-list()
resid_y <- W_now <- list() #data for iteration
first_eigen_val <- mse_W <- mse_y <-rep(NA, n_iter)
# 2. constraint matrix is the same at every iteration
J_star          <- get_jacobian_hybrid(W)
J_dotdot_star   <- get_penalty_hybrid(W)
lambda_mat      <- get_smoothing_param_hybrid(W, lambda)
constr_mat      <- J_star + (lambda_mat %*% J_dotdot_star) # denominator in the equation (6)
constr_mat_chol <- t(chol(constr_mat))
W_now[[1]] <- W
y_now <- y
final_succesful_iteration <- 0
for (l in 1:n_iter) {
#cat(paste("#############################################", "\n"))
if(verbose==T)cat(paste(l, "th component", "\n"))
# STEP 1. calculate pls score
pls_result_now <- get_pls_comp(W_now[[l]], y_now, constr_mat_chol, verbose)
if(!is.list(pls_result_now)){break}
xi[[l]] <- pls_result_now$xi # pls component. Section 3.2
rho[[l]] <- hybrid_inner_prod(W_now[[l]], xi[[l]]) # pls scores : n_sample * 1 matrix
# STEP 2. residulize
# residualize predictor: hybrid (W) on scalar (rho) linear regression with n_sample observations
delta[[l]] <- LSE_hybrid(W_now[[l]], rho[[l]]) #single obs of hybrid predictor
fitted_value_W[[l]] <- fitted_value(delta[[l]], rho[[l]])
W_now[[l+1]] <- subtr(W_now[[l]], fitted_value_W[[l]])
# residualize resoponse
nu[[l]] <- LSE_ptws(y_now, rho[[l]]) #scalar on scalar linear regression with n_sample observations
fitted_value_y[[l]] <- nu[[l]] * rho[[l]]
y_now <- y_now - fitted_value_y[[l]]
resid_y[[l]] <- y_now
#check mean norm
#mse_W[l] <- mean_sum_sqrd(W_now[[l]])
#mse_y[l] <- norm(y_now,"2")
#cat("W:", mse_W[l], "\n")
#cat("y:",  mse_y[l], "\n\n")
# STEP 3.
sigma[[l]] <- xi[[l]]
if (l == 1) {
eta[[l]] <- scalar_mul(sigma[[l]], nu[[l]])
}else{ # if l > 1
for (u in 1:(l - 1)){
sigma[[l]] <- subtr( sigma[[l]], sigma[[u]], hybrid_inner_prod(delta[[u]], xi[[l]]) )
} #end of u-loop
eta[[l]] <- add(eta[[l-1]], sigma[[l]], nu[[l]])
}#if statement
# just for records.
E[[l]] <- pls_result_now$E # for monitoring symetricity
V_star[[l]] <- pls_result_now$V_star
eigen_val[[l]] <- pls_result_now$eigen_val
first_eigen_val[l] <- eigen_val[[l]][1]
final_succesful_iteration <- l
}# for loop: l
}
#' Construct block-diagonal Gram matrix for hybrid predictor
#'
#' Returns a block-diagonal matrix containing the Gram  matrices for
#' each functional component and an identity matrix for the scalar part.
#'
#' @param obj A `predictor_hybrid` object.
#'
#' @return A block-diagonal matrix of size `(total_dim × total_dim)` where
#' functional and scalar components are arranged in order.
#' @export
get_gram_matrix_block <- function(obj) {
if (!inherits(obj, "predictor_hybrid")) {
stop("Input must be of class 'predictor_hybrid'.")
}
gram_blocks <- c(obj$gram_list, list(diag(obj$n_scalar)))
Matrix::bdiag(gram_blocks)
}
#' Compute V matrix (pre-corrected covariance estimator)
#'
#' Constructs the V matrix involving inner products of functional predictors
#' (weighted by their Gram matrices) and scalar predictors against response y.
#'
#' @param W A `predictor_hybrid` object.
#' @param y A numeric response vector of length equal to number of samples.
#'
#' @return A matrix representing the corrected cross-covariance structure.
#' @export
get_pre_corrcov <- function(W, y){
n <- W$n_sample
K <- W$n_functional
# building blocks
## 1. C_J : C multiplied by J. Scalable to arbitrary K
predictor_first <- W$functional_list[[1]]
C_J <- t(predictor_first$coefs) %*% W$gram_list[[1]]
for (i in 2:K){
predictor_now <- W$functional_list[[i]]
C_J <- cbind(
C_J,
t(predictor_now$coefs) %*% W$gram_list[[i]]
)
}
## 2. easy ones - covariance
J_Ct_y <- t(C_J) %*% y
Zt_y <- t(W$Z) %*% y
#print(J_Ct_y)
#print(Zt_y)
# V matrix
upper_left <- J_Ct_y %*% t(J_Ct_y)
upper_right <- J_Ct_y %*% t(Zt_y)
lower_left <- t(upper_right)
lower_right <- Zt_y %*% t(Zt_y)
V_star <- cbind(
rbind(upper_left, lower_left),
rbind(upper_right, lower_right)
)/(n^2)
return(V_star)
}
testthat::test_that("get_pre_corrcov returns valid matrix output", {
suppressPackageStartupMessages(library(fda))
# Create a basis and sample data
basis <- create.bspline.basis(c(0, 1), 5)
make_fd <- function(val, n_sample) {
fd(coef = matrix(val, 5, n_sample), basisobj = basis)
}
n <- 10
fd1 <- make_fd(1, n)
fd2 <- make_fd(2, n)
Z <- matrix(rnorm(n * 3), nrow = n)
y <- rnorm(n)
# Create predictor_hybrid object
obj <- predictor_hybrid(
Z = Z,
functional_list = list(fd1, fd2)
)
# Run function
V <- get_pre_corrcov(obj, y)
# Test output properties
expect_type(V, "double")
expect_true(is.matrix(V))
expect_equal(dim(V), rep(5 * 2 + 3, 2))  # 10 from 2 fds (5 each), 3 scalar
# Check symmetry
expect_equal(V, t(V), tolerance = 1e-8)
# Check numeric values in a simplified case
fd_const <- make_fd(1, n)
obj_simple <- predictor_hybrid(
Z = matrix(1, nrow = n, ncol = 1),
functional_list = list(fd_const)
)
y_const <- rep(1, n)
V_simple <- get_pre_corrcov(obj_simple, y_const)
# Check that everything is non-negative and not NA
expect_true(all(!is.na(V_simple)))
expect_true(all(V_simple >= 0))
})
testthat::test_that("get_pre_corrcov returns valid matrix output", {
suppressPackageStartupMessages(library(fda))
# Create a basis and sample data
basis <- create.bspline.basis(c(0, 1), 5)
make_fd <- function(val, n_sample) {
fd(coef = matrix(val, 5, n_sample), basisobj = basis)
}
n <- 10
fd1 <- make_fd(1, n)
fd2 <- make_fd(2, n)
Z <- matrix(rnorm(n * 3), nrow = n)
y <- rnorm(n)
# Create predictor_hybrid object
obj <- predictor_hybrid(
Z = Z,
functional_list = list(fd1, fd2)
)
# Run function
V <- get_pre_corrcov(obj, y)
# Test output properties
expect_true(is.matrix(V))
expect_equal(dim(V), rep(5 * 2 + 3, 2))  # 10 from 2 fds (5 each), 3 scalar
# Check symmetry
expect_equal(V, t(V), tolerance = 1e-8)
# Check numeric values in a simplified case
fd_const <- make_fd(1, n)
obj_simple <- predictor_hybrid(
Z = matrix(1, nrow = n, ncol = 1),
functional_list = list(fd_const)
)
y_const <- rep(1, n)
V_simple <- get_pre_corrcov(obj_simple, y_const)
# Check that everything is non-negative and not NA
expect_true(all(!is.na(V_simple)))
expect_true(all(V_simple >= 0))
})
basis <- create.bspline.basis(c(0, 1), 5)
make_fd <- function(val, n_sample) {
fd(coef = matrix(val, 5, n_sample), basisobj = basis)
}
n <- 10
fd1 <- make_fd(1, n)
fd2 <- make_fd(2, n)
Z <- matrix(rnorm(n * 3), nrow = n)
y <- rnorm(n)
# Create predictor_hybrid object
obj <- predictor_hybrid(
Z = Z,
functional_list = list(fd1, fd2)
)
# Run function
V <- get_pre_corrcov(obj, y)
V
expect_true(is.matrix(V))
is.matrix(V)
testthat::test_that("get_pre_corrcov returns valid matrix output", {
suppressPackageStartupMessages(library(fda))
# Create a basis and sample data
basis <- create.bspline.basis(c(0, 1), 5)
make_fd <- function(val, n_sample) {
fd(coef = matrix(val, 5, n_sample), basisobj = basis)
}
n <- 10
fd1 <- make_fd(1, n)
fd2 <- make_fd(2, n)
Z <- matrix(rnorm(n * 3), nrow = n)
y <- rnorm(n)
# Create predictor_hybrid object
obj <- predictor_hybrid(
Z = Z,
functional_list = list(fd1, fd2)
)
# Run function
V <- get_pre_corrcov(obj, y)
# Test output properties
expect_equal(dim(V), rep(5 * 2 + 3, 2))  # 10 from 2 fds (5 each), 3 scalar
# Check symmetry
expect_equal(V, t(V), tolerance = 1e-8)
# Check numeric values in a simplified case
fd_const <- make_fd(1, n)
obj_simple <- predictor_hybrid(
Z = matrix(1, nrow = n, ncol = 1),
functional_list = list(fd_const)
)
y_const <- rep(1, n)
V_simple <- get_pre_corrcov(obj_simple, y_const)
# Check that everything is non-negative and not NA
expect_true(all(!is.na(V_simple)))
expect_true(all(V_simple >= 0))
})
testthat::test_that("get_pre_corrcov returns valid matrix output", {
suppressPackageStartupMessages(library(fda))
# Create a basis and sample data
basis <- create.bspline.basis(c(0, 1), 5)
make_fd <- function(val, n_sample) {
fd(coef = matrix(val, 5, n_sample), basisobj = basis)
}
n <- 10
fd1 <- make_fd(1, n)
fd2 <- make_fd(2, n)
Z <- matrix(rnorm(n * 3), nrow = n)
y <- rnorm(n)
# Create predictor_hybrid object
obj <- predictor_hybrid(
Z = Z,
functional_list = list(fd1, fd2)
)
# Run function
V <- get_pre_corrcov(obj, y)
# Test output properties
expect_equal(dim(V), rep(5 * 2 + 3, 2))  # 10 from 2 fds (5 each), 3 scalar
# Check symmetry
expect_equal(V, t(V), tolerance = 1e-8)
# Check numeric values in a simplified case
fd_const <- make_fd(1, n)
obj_simple <- predictor_hybrid(
Z = matrix(1, nrow = n, ncol = 1),
functional_list = list(fd_const)
)
y_const <- rep(1, n)
V_simple <- get_pre_corrcov(obj_simple, y_const)
# Check that everything is non-negative and not NA
expect_true(all(!is.na(V_simple)))
expect_true(all(V_simple >= 0))
})
testthat::test_that("get_pre_corrcov returns correct covariance structure", {
suppressPackageStartupMessages(library(fda))
suppressPackageStartupMessages(library(testthat))
# Helper to create fd object
make_fd <- function(val, n_sample, basis) {
fd(coef = matrix(val, nrow = basis$nbasis, ncol = n_sample), basisobj = basis)
}
# Create basis
basis <- create.bspline.basis(c(0, 1), nbasis = 5)
# Functional and scalar parts
n_sample <- 3
n_functional <- 2
n_scalar <- 3
# Functional list: two identical fd objects with constant basis coefficients
fd1 <- make_fd(1, n_sample, basis)
fd2 <- make_fd(2, n_sample, basis)
functional_list <- list(fd1, fd2)
# Scalar covariates
Z <- matrix(1, nrow = n_sample, ncol = n_scalar)
# Response vector
y <- matrix(1:n_sample, ncol = 1)
# Construct hybrid object
W <- predictor_hybrid(Z = Z, functional_list = functional_list)
# Run get_pre_corrcov
V <- get_pre_corrcov(W, y)
# Check dimensions: (sum of basis × functional + scalar)^2
total_dim <- sum(W$n_basis_list) + W$n_scalar
testthat::expect_equal(dim(V), c(total_dim, total_dim))
# Check symmetry
testthat::expect_true(isTRUE(all.equal(V, t(V))))
# Check positive semi-definiteness (eigenvalues should be >= 0)
testthat::expect_true(all(eigen(V, only.values = TRUE)$values >= -1e-8))
# Check values for known constant structure
# Since coefficients and inputs are constant, all values should be positive
testthat::expect_true(all(V >= 0))
})
testthat::test_that("get_pre_corrcov handles constant and random coefficients", {
suppressPackageStartupMessages(library(fda))
make_fd <- function(coefs, basis) {
fd(coef = coefs, basisobj = basis)
}
basis <- create.bspline.basis(c(0, 1), nbasis = 4)
n_sample <- 5
n_scalar <- 2
n_functional <- 2
# Constant coefficients
fd_const1 <- make_fd(matrix(1, 4, n_sample), basis)
fd_const2 <- make_fd(matrix(2, 4, n_sample), basis)
Z_const <- matrix(1, n_sample, n_scalar)
y_const <- matrix(1:n_sample, ncol = 1)
obj_const <- predictor_hybrid(Z = Z_const, functional_list = list(fd_const1, fd_const2))
V_const <- get_pre_corrcov(obj_const, y_const)
testthat::expect_equal(dim(V_const), rep(sum(obj_const$n_basis_list) + obj_const$n_scalar, 2))
testthat::expect_true(isSymmetric(V_const))
testthat::expect_true(all(V_const >= 0))
# Random coefficients
set.seed(123)
fd_rand1 <- make_fd(matrix(rnorm(4 * n_sample), 4, n_sample), basis)
fd_rand2 <- make_fd(matrix(rnorm(4 * n_sample), 4, n_sample), basis)
Z_rand <- matrix(rnorm(n_sample * n_scalar), n_sample, n_scalar)
y_rand <- matrix(rnorm(n_sample), ncol = 1)
obj_rand <- predictor_hybrid(Z = Z_rand, functional_list = list(fd_rand1, fd_rand2))
V_rand <- get_pre_corrcov(obj_rand, y_rand)
testthat::expect_equal(dim(V_rand), rep(sum(obj_rand$n_basis_list) + obj_rand$n_scalar, 2))
testthat::expect_true(isSymmetric(V_rand))
testthat::expect_true(all(eigen(V_rand, only.values = TRUE)$values >= -1e-8))
})
#' Construct the roughness penalty matrix for a predictor_hybrid object
#'
#' Returns a block diagonal matrix representing roughness penalties for each functional predictor
#' and zeros for the scalar predictors (scalar predictors are not penalized). Each functional component uses its own basis penalty matrix, computed via second derivative penalty via `getbasispenalty()` from the `fda` package
#'
#' @param W A `predictor_hybrid` object.
#'
#' @return A block diagonal penalty matrix of dimension `(sum(n_basis_list) + n_scalar)^2`.
#' @export
get_penalty_hybrid <- function(W){
J_dotdot_star <- fda::getbasispenalty(W$functional_list[[1]]$basis)
for (ii in 2:(W$n_functional)){
J_dotdot_star <- Matrix::bdiag(
J_dotdot_star,
fda::getbasispenalty(W$functional_list[[ii]]$basis)
)
}
J_dotdot_star <- Matrix::bdiag(
J_dotdot_star,
matrix(0, nrow = W$n_scalar, ncol = W$n_scalar)
)
return(J_dotdot_star)
}
testthat::test_that("get_penalty_hybrid computes correct dimensions and structure", {
suppressPackageStartupMessages(library(fda))
# Setup
basis <- fda::create.bspline.basis(c(0, 1), nbasis = 5)
n_sample <- 3
n_scalar <- 2
fd1 <- fda::fd(coef = matrix(1, 5, n_sample), basisobj = basis)
fd2 <- fda::fd(coef = matrix(2, 5, n_sample), basisobj = basis)
Z <- matrix(rnorm(n_sample * n_scalar), n_sample, n_scalar)
obj <- predictor_hybrid(Z = Z, functional_list = list(fd1, fd2))
# Run
penalty <- get_penalty_hybrid(obj)
# Expected dimensions
total_dim <- sum(obj$n_basis_list) + obj$n_scalar
testthat::expect_equal(dim(penalty), c(total_dim, total_dim))
# Check block diagonal structure: bottom-right should be zero matrix
scalar_block <- as.matrix(penalty[
(total_dim - n_scalar + 1):total_dim,
(total_dim - n_scalar + 1):total_dim
])
testthat::expect_equal(scalar_block, matrix(0, n_scalar, n_scalar))
# Check that the upper blocks are positive semidefinite
eigenvalues <- eigen(as.matrix(penalty[1:(total_dim - n_scalar), 1:(total_dim - n_scalar)]))$values
testthat::expect_true(all(eigenvalues >= -1e-8))  # Numerical tolerance
})
