results <- data.frame()
# Sweep over settings
for (nbasis in nbasis_vals) {
for (lambda in lambda_vals) {
cat("Trying nbasis =", nbasis, ", lambda =", lambda, "\n")
# Generate data
fd1 <- generate_fd_data(n_sample, nbasis, freq = 1)
fd2 <- generate_fd_data(n_sample, nbasis, freq = 2)
Z <- matrix(rnorm(n_sample * n_scalar), n_sample, n_scalar)
y <- rnorm(n_sample)
W <- predictor_hybrid(Z = Z, functional_list = list(fd1, fd2))
lambda_vec <- rep(lambda, n_functional)
# Try to build constraint matrix L
L <- tryCatch({
get_constraint_matrix_hybrid(W, lambda_vec)
}, error = function(e) NA)
if (!is.matrix(L)) {
results <- rbind(results, data.frame(
nbasis = nbasis,
lambda = lambda,
eigen_val = NA,
is_real = FALSE
))
next
}
# Run get_pls_comp safely
pls <- get_pls_comp(W, y, L)
}}
# View success cases
cat("\nSettings that yield real-valued eigenvectors:\n")
print(subset(results, is_real == TRUE))
# Plot
ggplot(results, aes(x = nbasis, y = lambda, fill = is_real)) +
geom_tile(color = "white") +
scale_fill_manual(values = c("red", "green"), labels = c("Complex/Error", "Real")) +
scale_y_log10() +
labs(
title = "Stability of get_pls_comp Across Î» and Basis Size",
x = "# of Basis Functions",
y = "Smoothing Parameter Î» (log-scale)",
fill = "Eigenvalue Real?"
)
suppressPackageStartupMessages({
library(fda)
library(Matrix)
library(ggplot2)
})
# --- Helper: Generate realistic smooth functional data ---
generate_fd_data <- function(n_sample, nbasis, freq = 1) {
basis <- create.bspline.basis(c(0, 1), nbasis = nbasis, norder = 4)
time_points <- seq(0, 1, length.out = nbasis)
coefs <- outer(1:nbasis, 1:n_sample, function(i, j) {
sin(freq * pi * time_points[i]) + rnorm(1, sd = 0.1)
})
fd(coef = coefs, basisobj = basis)
}
# --- Settings ---
set.seed(20250604)
n_sample <- 30
n_scalar <- 3
n_functional <- 2
nbasis_vals <- 4:20
lambda_vals <- c(0, 1e-8, 1e-6, 1e-4, 1e-2, 1, 10)
results <- data.frame()
# --- Experiment Loop ---
for (nbasis in nbasis_vals) {
for (lambda in lambda_vals) {
cat("Trying nbasis =", nbasis, ", lambda =", lambda, "\n")
# Generate functional predictors
fd1 <- generate_fd_data(n_sample, nbasis, freq = 1)
fd2 <- generate_fd_data(n_sample, nbasis, freq = 2)
Z <- matrix(rnorm(n_sample * n_scalar), n_sample, n_scalar)
y <- rnorm(n_sample)
W <- predictor_hybrid(Z = Z, functional_list = list(fd1, fd2))
lambda_vec <- rep(lambda, n_functional)
# Try to compute constraint matrix L
L <- tryCatch({
get_constraint_matrix_hybrid(W, lambda_vec)
}, error = function(e) NA)
if (!is.matrix(L)) {
results <- rbind(results, data.frame(
nbasis = nbasis,
lambda = lambda,
eigen_val = NA,
is_real = FALSE,
reason = "error in get_constraint_matrix_hybrid"
))
next
}
# Try get_pls_comp and check for valid output
out <- tryCatch({
pls <- get_pls_comp(W, y, L)
if (!is.list(pls) || (is.character(pls) && pls == "stop")) {
data.frame(
nbasis = nbasis,
lambda = lambda,
eigen_val = NA,
is_real = FALSE,
reason = "stop (complex eigenvector)"
)
} else {
data.frame(
nbasis = nbasis,
lambda = lambda,
eigen_val = Re(pls$eigen_val),
is_real = TRUE,
reason = "success"
)
}
}, error = function(e) {
data.frame(
nbasis = nbasis,
lambda = lambda,
eigen_val = NA,
is_real = FALSE,
reason = "error in get_pls_comp"
)
})
results <- rbind(results, out)
}
}
# --- Print successful configurations ---
cat("\nâœ… Successful runs with real eigenvalues:\n")
print(subset(results, is_real == TRUE))
# --- Visualize success/failure ---
ggplot(results, aes(x = nbasis, y = lambda, fill = reason)) +
geom_tile(color = "white") +
scale_y_log10() +
scale_fill_manual(values = c(
"success" = "green",
"stop (complex eigenvector)" = "orange",
"error in get_constraint_matrix_hybrid" = "red",
"error in get_pls_comp" = "darkred"
)) +
labs(
title = "get_pls_comp Outcomes: Î» vs. # Basis Functions",
x = "# of Basis Functions",
y = "Smoothing Parameter Î» (log scale)",
fill = "Result Type"
)
results
get_constraint_matrix_hybrid(W, lambda_vec)
suppressPackageStartupMessages({
library(fda)
library(Matrix)
library(ggplot2)
})
# --- Helper: Generate realistic smooth functional data ---
generate_fd_data <- function(n_sample, nbasis, freq = 1) {
basis <- create.bspline.basis(c(0, 1), nbasis = nbasis, norder = 4)
time_points <- seq(0, 1, length.out = nbasis)
coefs <- outer(1:nbasis, 1:n_sample, function(i, j) {
sin(freq * pi * time_points[i]) + rnorm(1, sd = 0.1)
})
fd(coef = coefs, basisobj = basis)
}
# --- Settings ---
set.seed(20250604)
n_sample <- 30
n_scalar <- 3
n_functional <- 2
nbasis_vals <- 4:20
lambda_vals <- c(0, 1e-8, 1e-6, 1e-4, 1e-2, 1, 10)
results <- data.frame()
# --- Experiment Loop ---
for (nbasis in nbasis_vals) {
for (lambda in lambda_vals) {
cat("Trying nbasis =", nbasis, ", lambda =", lambda, "\n")
# Generate functional predictors
fd1 <- generate_fd_data(n_sample, nbasis, freq = 1)
fd2 <- generate_fd_data(n_sample, nbasis, freq = 2)
Z <- matrix(rnorm(n_sample * n_scalar), n_sample, n_scalar)
y <- rnorm(n_sample)
W <- predictor_hybrid(Z = Z, functional_list = list(fd1, fd2))
lambda_vec <- rep(lambda, n_functional)
# Try to compute constraint matrix L
L <- get_constraint_matrix_hybrid(W, lambda_vec)
constr_mat_chol <- t(chol(L))
# Try get_pls_comp and check for valid output
out <- tryCatch({
pls <- get_pls_comp(W, y, constr_mat_chol)
if (!is.list(pls) || (is.character(pls) && pls == "stop")) {
data.frame(
nbasis = nbasis,
lambda = lambda,
eigen_val = NA,
is_real = FALSE,
reason = "stop (complex eigenvector)"
)
} else {
data.frame(
nbasis = nbasis,
lambda = lambda,
eigen_val = Re(pls$eigen_val),
is_real = TRUE,
reason = "success"
)
}
}, error = function(e) {
data.frame(
nbasis = nbasis,
lambda = lambda,
eigen_val = NA,
is_real = FALSE,
reason = "error in get_pls_comp"
)
})
results <- rbind(results, out)
}
}
# --- Print successful configurations ---
cat("\nâœ… Successful runs with real eigenvalues:\n")
print(subset(results, is_real == TRUE))
# --- Visualize success/failure ---
ggplot(results, aes(x = nbasis, y = lambda, fill = reason)) +
geom_tile(color = "white") +
scale_y_log10() +
scale_fill_manual(values = c(
"success" = "green",
"stop (complex eigenvector)" = "orange",
"error in get_constraint_matrix_hybrid" = "red",
"error in get_pls_comp" = "darkred"
)) +
labs(
title = "get_pls_comp Outcomes: Î» vs. # Basis Functions",
x = "# of Basis Functions",
y = "Smoothing Parameter Î» (log scale)",
fill = "Result Type"
)
suppressPackageStartupMessages({
library(fda)
library(Matrix)
library(ggplot2)
})
# --- Helper: Generate realistic smooth functional data ---
generate_fd_data <- function(n_sample, nbasis, freq = 1) {
basis <- create.bspline.basis(c(0, 1), nbasis = nbasis, norder = 4)
time_points <- seq(0, 1, length.out = nbasis)
coefs <- outer(1:nbasis, 1:n_sample, function(i, j) {
sin(freq * pi * time_points[i]) + rnorm(1, sd = 0.1)
})
fd(coef = coefs, basisobj = basis)
}
# --- Settings ---
set.seed(20250604)
n_sample <- 30
n_scalar <- 10
n_functional <- 2
nbasis_vals <- 4:20
lambda_vals <- c(0, 1e-8, 1e-6, 1e-4, 1e-2, 1, 10)
results <- data.frame()
# --- Experiment Loop ---
for (nbasis in nbasis_vals) {
for (lambda in lambda_vals) {
cat("Trying nbasis =", nbasis, ", lambda =", lambda, "\n")
# Generate functional predictors
fd1 <- generate_fd_data(n_sample, nbasis, freq = 1)
fd2 <- generate_fd_data(n_sample, nbasis, freq = 2)
Z <- matrix(rnorm(n_sample * n_scalar), n_sample, n_scalar)
y <- rnorm(n_sample)
W <- predictor_hybrid(Z = Z, functional_list = list(fd1, fd2))
lambda_vec <- rep(lambda, n_functional)
# Try to compute constraint matrix L
L <- get_constraint_matrix_hybrid(W, lambda_vec)
constr_mat_chol <- t(chol(L))
# Try get_pls_comp and check for valid output
out <- tryCatch({
pls <- get_pls_comp(W, y, constr_mat_chol)
if (!is.list(pls) || (is.character(pls) && pls == "stop")) {
data.frame(
nbasis = nbasis,
lambda = lambda,
eigen_val = NA,
is_real = FALSE,
reason = "stop (complex eigenvector)"
)
} else {
data.frame(
nbasis = nbasis,
lambda = lambda,
eigen_val = Re(pls$eigen_val),
is_real = TRUE,
reason = "success"
)
}
}, error = function(e) {
data.frame(
nbasis = nbasis,
lambda = lambda,
eigen_val = NA,
is_real = FALSE,
reason = "error in get_pls_comp"
)
})
results <- rbind(results, out)
}
}
# --- Print successful configurations ---
cat("\nâœ… Successful runs with real eigenvalues:\n")
print(subset(results, is_real == TRUE))
# --- Visualize success/failure ---
ggplot(results, aes(x = nbasis, y = lambda, fill = reason)) +
geom_tile(color = "white") +
scale_y_log10() +
scale_fill_manual(values = c(
"success" = "green",
"stop (complex eigenvector)" = "orange",
"error in get_constraint_matrix_hybrid" = "red",
"error in get_pls_comp" = "darkred"
)) +
labs(
title = "get_pls_comp Outcomes: Î» vs. # Basis Functions",
x = "# of Basis Functions",
y = "Smoothing Parameter Î» (log scale)",
fill = "Result Type"
)
suppressPackageStartupMessages({
library(fda)
library(Matrix)
library(ggplot2)
})
# --- Helper: Generate realistic smooth functional data ---
generate_fd_data <- function(n_sample, nbasis, freq = 1) {
basis <- create.bspline.basis(c(0, 1), nbasis = nbasis, norder = 4)
time_points <- seq(0, 1, length.out = nbasis)
coefs <- outer(1:nbasis, 1:n_sample, function(i, j) {
sin(freq * pi * time_points[i]) + rnorm(1, sd = 0.1)
})
fd(coef = coefs, basisobj = basis)
}
# --- Settings ---
set.seed(20250604)
n_sample <- 30
n_scalar <- 10
n_functional <- 2
nbasis_vals <- 4:20
lambda_vals <- c(0, 1e-8, 1e-6, 1e-4, 1e-2, 1, 10)
results <- data.frame()
# --- Experiment Loop ---
for (nbasis in nbasis_vals) {
for (lambda in lambda_vals) {
cat("Trying nbasis =", nbasis, ", lambda =", lambda, "\n")
# Generate functional predictors
fd1 <- generate_fd_data(n_sample, nbasis, freq = 1)
fd2 <- generate_fd_data(n_sample, nbasis, freq = 2)
Z <- matrix(rnorm(n_sample * n_scalar), n_sample, n_scalar)
y <- rnorm(n_sample)
W <- predictor_hybrid(Z = Z, functional_list = list(fd1, fd2))
lambda_vec <- rep(lambda, n_functional)
# Try to compute constraint matrix L
L <- get_constraint_matrix_hybrid(W, lambda_vec)
constr_mat_chol <- t(chol(L))  # <-- do not change this
# Time the PLS computation
elapsed <- system.time({
out <- tryCatch({
pls <- get_pls_comp(W, y, constr_mat_chol)
if (!is.list(pls) || (is.character(pls) && pls == "stop")) {
data.frame(
nbasis = nbasis,
lambda = lambda,
eigen_val = NA,
is_real = FALSE,
reason = "stop (complex eigenvector)",
time_sec = NA_real_
)
} else {
data.frame(
nbasis = nbasis,
lambda = lambda,
eigen_val = Re(pls$eigen_val),
is_real = TRUE,
reason = "success",
time_sec = NA_real_  # placeholder, will update below
)
}
}, error = function(e) {
data.frame(
nbasis = nbasis,
lambda = lambda,
eigen_val = NA,
is_real = FALSE,
reason = "error in get_pls_comp",
time_sec = NA_real_
)
})
})
out$time_sec <- elapsed["elapsed"]
results <- rbind(results, out)
}
}
# --- Print successful configurations ---
cat("\nâœ… Successful runs with real eigenvalues:\n")
print(subset(results, is_real == TRUE))
# --- Fastest and slowest ---
cat("\nâ±ï¸ Top 5 fastest settings:\n")
print(head(results[order(results$time_sec), ], 5))
cat("\nğŸ¢ Top 5 slowest settings:\n")
print(tail(results[order(results$time_sec), ], 5))
# --- Visualize success/failure ---
ggplot(results, aes(x = nbasis, y = lambda, fill = reason)) +
geom_tile(color = "white") +
scale_y_log10() +
scale_fill_manual(values = c(
"success" = "green",
"stop (complex eigenvector)" = "orange",
"error in get_constraint_matrix_hybrid" = "red",
"error in get_pls_comp" = "darkred"
)) +
labs(
title = "get_pls_comp Outcomes: Î» vs. # Basis Functions",
x = "# of Basis Functions",
y = "Smoothing Parameter Î» (log scale)",
fill = "Result Type"
)
suppressPackageStartupMessages({
library(fda)
library(Matrix)
library(ggplot2)
})
# --- Helper: Generate realistic smooth functional data ---
generate_fd_data <- function(n_sample, nbasis, freq = 1) {
basis <- create.bspline.basis(c(0, 1), nbasis = nbasis, norder = 4)
time_points <- seq(0, 1, length.out = nbasis)
coefs <- outer(1:nbasis, 1:n_sample, function(i, j) {
sin(freq * pi * time_points[i]) + rnorm(1, sd = 0.1)
})
fd(coef = coefs, basisobj = basis)
}
# --- Settings ---
set.seed(20250604)
n_sample <- 200
n_scalar <- 10
n_functional <- 2
nbasis_vals <- c(4,8,12,16,20)
lambda_vals <- c(0, 1e-8, 1e-6, 1e-4, 1e-2, 1, 10)
results <- data.frame()
# --- Experiment Loop ---
for (nbasis in nbasis_vals) {
for (lambda in lambda_vals) {
cat("Trying nbasis =", nbasis, ", lambda =", lambda, "\n")
# Generate functional predictors
fd1 <- generate_fd_data(n_sample, nbasis, freq = 1)
fd2 <- generate_fd_data(n_sample, nbasis, freq = 2)
Z <- matrix(rnorm(n_sample * n_scalar), n_sample, n_scalar)
y <- rnorm(n_sample)
W <- predictor_hybrid(Z = Z, functional_list = list(fd1, fd2))
lambda_vec <- rep(lambda, n_functional)
# Try to compute constraint matrix L
L <- get_constraint_matrix_hybrid(W, lambda_vec)
constr_mat_chol <- t(chol(L))  # <-- do not change this
# Time the PLS computation
elapsed <- system.time({
out <- tryCatch({
pls <- get_pls_comp(W, y, constr_mat_chol)
if (!is.list(pls) || (is.character(pls) && pls == "stop")) {
data.frame(
nbasis = nbasis,
lambda = lambda,
eigen_val = NA,
is_real = FALSE,
reason = "stop (complex eigenvector)",
time_sec = NA_real_
)
} else {
data.frame(
nbasis = nbasis,
lambda = lambda,
eigen_val = Re(pls$eigen_val),
is_real = TRUE,
reason = "success",
time_sec = NA_real_  # placeholder, will update below
)
}
}, error = function(e) {
data.frame(
nbasis = nbasis,
lambda = lambda,
eigen_val = NA,
is_real = FALSE,
reason = "error in get_pls_comp",
time_sec = NA_real_
)
})
})
out$time_sec <- elapsed["elapsed"]
results <- rbind(results, out)
}
}
# --- Print successful configurations ---
cat("\nâœ… Successful runs with real eigenvalues:\n")
print(subset(results, is_real == TRUE))
# --- Fastest and slowest ---
cat("\nâ±ï¸ Top 5 fastest settings:\n")
print(head(results[order(results$time_sec), ], 5))
cat("\nğŸ¢ Top 5 slowest settings:\n")
print(tail(results[order(results$time_sec), ], 5))
# --- Visualize success/failure ---
ggplot(results, aes(x = nbasis, y = lambda, fill = reason)) +
geom_tile(color = "white") +
scale_y_log10() +
scale_fill_manual(values = c(
"success" = "green",
"stop (complex eigenvector)" = "orange",
"error in get_constraint_matrix_hybrid" = "red",
"error in get_pls_comp" = "darkred"
)) +
labs(
title = "get_pls_comp Outcomes: Î» vs. # Basis Functions",
x = "# of Basis Functions",
y = "Smoothing Parameter Î» (log scale)",
fill = "Result Type"
)
