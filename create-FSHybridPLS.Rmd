---
title: "Creating the ``r params$package_name`` R package"
author: "Your Name"
date: "The Date"
knit: litr::render
output: litr::litr_html_document
params:
  package_name: "FSHybridPLS" # <-- change this to your package name
  package_parent_dir: "." # <-- relative to this file's location
---

<!-- This Rmd file contains all the code needed to define an R package.  Press "Knit" in RStudio or more generally run `litr::render("name-of-this-file.Rmd")` to generate the R package.  Remember that when you want to modify anything about the R package, you should modify this document rather than the package that is outputted.
-->

## Package setup

We start by specifying the information needed in the DESCRIPTION file of the R package.

```{r package-setup, message=FALSE, results='hide'}
usethis::create_package(
  path = ".",
  fields = list(
    Package = params$package_name,
    Version = "0.0.0.9000",
    Title = "A Package That Says Hello",
    Description = "This package says hello.  But its actual purpose is to show how an R package can be completely coded in a single R markdown file.",
    Imports = "fda (>= 6.1.3), Matrix",
    `Authors@R` = person(
      given = "First",
      family = "Last",
      email = "you@gmail.com",
      role = c("aut", "cre")
      )
  )
)
usethis::use_mit_license(copyright_holder = "F. Last")
```


# helper functions

### is_same_basis
```{r}
#' @export
is_same_basis <- function(input, other) {
  all(
    length(input$functional_list) == length(other$functional_list),
    all(
      mapply(function(fd1, fd2) fda::is.eqbasis(fd1$basis, fd2$basis),
             input$functional_list, other$functional_list)
    )
  )
}
```


### compute_gram_matrix
```{r}
#' Compute the Gram matrix for a basis object
#'
#' @param basis A basis object of class `basisfd` from the `fda` package
#' @return A square matrix where entry (i,j) is the inner product of basis functions i and j
#' @export
compute_gram_matrix <- function(basis) {
  stopifnot(inherits(basis, "basisfd"))
  inprod(basis, basis)  # computes ∫ b_i(t) b_j(t) dt
}

```

We check the following cases:

| Case | Test                 | Expectation                             |
|------|----------------------|------------------------------------------|
| 1    | Orthogonal (Fourier) | Gram matrix ≈ diagonal                  |
| 2    | Constant             | Single value equals interval length (1) |
| 3    | Invalid              | Raises informative error                |
| 4    | Narrow support       | Mostly low off-diagonal entries         |


```{r}
testthat::test_that("Gram matrix edge cases", {
  suppressPackageStartupMessages(library(fda))

  # Case 1: Fourier basis (orthogonal over [0, 1])
  fb <- create.fourier.basis(rangeval = c(0, 1), nbasis = 5)
  J_fourier <- compute_gram_matrix(fb)
  testthat::expect_equal(J_fourier, diag(diag(J_fourier)), tolerance = 1e-10)  # Nearly diagonal

  # Case 2: Constant basis (1 basis function)
  cb <- create.constant.basis(rangeval = c(0, 1))
  J_const <- compute_gram_matrix(cb)
  testthat::expect_equal(dim(J_const), c(1, 1))
  testthat::expect_equal(J_const[1, 1], 1)

  # Case 3: Invalid input
  testthat::expect_error(compute_gram_matrix("not a basisfd"))

  # Case 4: Highly localized B-splines
  # Simulate nearly disjoint support (narrow B-splines)
  narrow_bs <- create.bspline.basis(rangeval = c(0, 1), nbasis = 10, norder = 2)
  J_narrow <- compute_gram_matrix(narrow_bs)
  testthat::expect_true(all(abs(J_narrow[upper.tri(J_narrow)]) < 0.5))  # off-diagonals small
})


```


## helpers for functional data objects

### rep_fd

```{r}
#' Replicate a list of single-sample fd objects multiple times
#'
#' This function broadcasts a list of single-sample functional predictors
#' by replicating their coefficient columns.
#'
#' @param fd_list A list of `fd` objects, each representing a single sample.
#' @param n The number of replications desired.
#'
#' @return A list of `fd` objects, each with `n` replications.
#' @export
rep_fd <- function(fd_list, n) {
  if (!is.list(fd_list) || any(!vapply(fd_list, inherits, logical(1), "fd"))) {
    stop("Input must be a list of 'fd' objects.")
  }

  lapply(fd_list, function(fd_obj) {
    coef_mat <- fd_obj$coefs
    if (is.null(dim(coef_mat)) || ncol(coef_mat) != 1) {
      stop("Each fd object in the list must have one column of coefficients.")
    }

    new_coefs <- matrix(rep(coef_mat, n), nrow = nrow(coef_mat), ncol = n)
    fd(coef = new_coefs, basisobj = fd_obj$basis)
  })
}
```

| Case | Description                            | Input Type               | Expected Output                        | Notes                                            |
|------|----------------------------------------|--------------------------|----------------------------------------|--------------------------------------------------|
| 1    | Correct replication                    | List of single-sample fd | List of `fd` objects with `n` columns | All columns identical to original coefficients   |
| 2    | Each fd has one sample                 | List of fd               | No error                               | Verifies structure and content                  |
| 3    | One fd has multiple samples            | fd with >1 columns       | Error                                   | Should raise informative error                  |
| 4    | Non-fd object in list                  | List of non-`fd` items   | Error                                   | Validates class-checking robustness             |


```{r}
testthat::test_that("rep_fd correctly replicates a list of fd objects", {
  suppressPackageStartupMessages(library(fda))

  # Create a simple basis
  basis <- create.bspline.basis(c(0, 1), 5)

  # Create single-sample fd object
  coef_vec <- 1:5
  fd1 <- fd(coef = matrix(coef_vec, ncol = 1), basisobj = basis)

  # Replicate the list
  rep_list <- rep_fd(list(fd1, fd1), 3)

  # Check: list length unchanged
  testthat::expect_equal(length(rep_list), 2)

  # Check each replicated fd object
  for (fd_obj in rep_list) {
    testthat::expect_s3_class(fd_obj, "fd")
    testthat::expect_equal(dim(fd_obj$coefs), c(5, 3))  # 5 basis × 3 samples
    for (i in 1:3) {
      testthat::expect_equal(fd_obj$coefs[, i], coef_vec)
    }
  }

  # Error if not single-sample
  fd_multi <- fd(coef = matrix(1:10, nrow = 5, ncol = 2), basisobj = basis)
  testthat::expect_error(rep_fd(list(fd_multi)), "Each fd object in the list must have one column")
  
  # Error on non-fd input
  testthat::expect_error(rep_fd(list(1, "not_fd")), "Input must be a list of 'fd' objects")
})


```

# Class predictor_hybrid
- Let $\{X^{(k)}\}_{k=1, \ldots, K}$ be a collection of random functions defined on unit hypercube domains $\mathcal{T}_k := [0,1]^{d_k}$ ($d_k \in \mathbb{N})$; i.e., $X^{(k)}: \mathcal{T}_k \rightarrow \mathbb{R}$.

- Assume that each $X^{(k)}$ is in $L^2(\mathcal{T}_k)$, a Hilbert space of square integrable functions with respect to Lebesgue measure $dt_k$ on $\mathcal{T}_k$. 

- Write  $X=(X^{(1)}, \ldots, X^{(K)})$ as a multivariate functional object that belongs to $\mathcal{F} = L^2(\mathcal{T}_1) \times \cdots \times L^2(\mathcal{T}_K)$---a cartesian product of individual $L^2(\mathcal{T}_k)$ spaces. 

- We can also express the functional object $X$ evaluated on the multi-dimensional argument $\mathbf{t} = (t_1, \ldots, t_k)^\top \in \mathcal{T} = \mathcal{T}_1 \times \cdots \times \mathcal{T}_K$ as a $K$-dimensional vector $X(\mathbf{t})=(X^{(1)}(t_1), \ldots, X^{(K)}(t_K))^\top$. 

- **Our strategy is to formulate a hybrid random object**, $\mathbf{W} = (X, \mathbf{Z})$, which combines $X$ and $p$-dimensional scalar covariate $\mathbf{Z}$ into an ordered pair belonging to $\mathcal{H} = \mathcal{F} \times \mathbb{R}^p$.  

- An alternative notation for the hybrid object can be obtained by evaluating its functional part on $\mathbf{t}$ and expressing it as a $(K+p)$-dimensional vector: $\mathbf{W}[\mathbf{t}] = (X(\mathbf{t}), \mathbf{Z})^\top$, with $X(\mathbf{t}) = (X^{(1)}(t_1), \ldots, X^{(K)}(t_K))^\top \in \mathbb{R}^K$ and $\mathbf{Z} = (Z_1, \ldots, Z_p)^\top  \in \mathbb{R}^p$.

- The hybrid object forms a Hilbert space, characterized by well-defined addition, scalar multiplication, and inner product operations. 

- We define an S3 object `predictor_hybrid` that represent this structure, and implement Hilbert space operations for this class, and our algorithm is built on these foundational operations.

The class definition is a simple list that contains a matrix and a collection of \code{fd} objects from the \code{fda} package, along with the necessary metadata.
```{r classdef:predictor_hybrid}

#' Create a predictor_hybrid object (S3 version, automatic basis size and Gram matrix)
#'
#' Constructs a hybrid predictor object that stores both scalar and functional predictors,
#' and automatically computes Gram matrices (inner products of basis functions).
#'
#' @param Z A numeric matrix of dimension \code{n_sample × n_scalar} representing scalar predictors.
#' @param functional_list A list of functional predictors (e.g., \code{fd} objects from the \code{fda} package).
#'
#' @return An object of class \code{predictor_hybrid}, containing scalar and functional data with Gram matrices.
#' @export
predictor_hybrid <- function(Z, functional_list) {
  stopifnot(is.matrix(Z), is.numeric(Z))
  stopifnot(is.list(functional_list))

  n_sample <- nrow(Z)
  n_scalar <- ncol(Z)
  n_functional <- length(functional_list)

  gram_list <- vector("list", n_functional)
  n_basis_list <- numeric(n_functional)

  for (i in seq_len(n_functional)) {
    fd_i <- functional_list[[i]]
    stopifnot(inherits(fd_i, "fd"))

    n_fd_sample <- ncol(coef(fd_i))
    if (n_fd_sample != n_sample) {
      stop(sprintf("Functional predictor %d has %d replicates, but Z has %d rows.",
                   i, n_fd_sample, n_sample))
    }

    basis_i <- fd_i$basis
    gram_list[[i]] <- compute_gram_matrix(basis_i)
    n_basis_list[i] <- basis_i$nbasis
  }

  structure(
    list(
      Z = Z,
      functional_list = functional_list,
      gram_list = gram_list,
      n_basis_list = n_basis_list,
      n_sample = n_sample,
      n_functional = n_functional,
      n_scalar = n_scalar
    ),
    class = "predictor_hybrid"
  )
}
```


Let's write some tests to make sure the function behaves as desired:
```{r}
testthat::test_that("predictor_hybrid constructor works as expected (S3, updated)", {
  suppressPackageStartupMessages(library(fda))

  # Create scalar matrix
  Z <- matrix(rnorm(100 * 5), nrow = 100, ncol = 5)

  # Create two fd objects with 100 replications
  basis1 <- create.bspline.basis(c(0, 1), nbasis = 10)
  basis2 <- create.bspline.basis(c(0, 1), nbasis = 20)

  coef1 <- matrix(rnorm(10 * 100), nrow = 10)  # 10 basis × 100 samples
  coef2 <- matrix(rnorm(20 * 100), nrow = 20)  # 20 basis × 100 samples

  fd1 <- fd(coef = coef1, basisobj = basis1)
  fd2 <- fd(coef = coef2, basisobj = basis2)

  # Construct object
  obj <- predictor_hybrid(Z = Z, functional_list = list(fd1, fd2))

  # Assertions
  testthat::expect_s3_class(obj, "predictor_hybrid")
  testthat::expect_equal(nrow(obj$Z), 100)
  testthat::expect_equal(ncol(obj$Z), 5)
  testthat::expect_equal(length(obj$functional_list), 2)
  testthat::expect_equal(obj$n_basis_list, c(10, 20))
  testthat::expect_equal(obj$n_sample, 100)
  testthat::expect_equal(obj$n_functional, 2)
  testthat::expect_equal(obj$n_scalar, 5)
  testthat::expect_equal(dim(obj$gram_list[[1]]), c(10, 10))
  testthat::expect_equal(dim(obj$gram_list[[2]]), c(20, 20))
})
```


### predictor_hybrid_from_coef
An alternative constructor for a predictor_hybrid object based on a flat numeric coefficient vector. It reconstructs both the functional and scalar components for a single-sample hybrid predictor object. The function reads the basis information from the template `format` object.

- Inputs
  - **`format`**: A `predictor_hybrid` object containing:
    - `functional_list`: List of `fd` objects with basis info
    - `gram_list`: List of Gram matrices
    - `n_scalar`: Number of scalar predictors
  - **`coef`**: Numeric vector of length `K * M + d`, where:
    - `K` = number of functional predictors  
    - `M` = number of basis functions (assumed same across predictors)  
    - `d` = number of scalar predictors

- Output
  - A `predictor_hybrid` object with:
    - Functional predictors rebuilt from the first `K * M` coefficients
    - Scalar predictor `Z` from the remaining `d` coefficients
    - `n_sample` set to 1

```{r}
#' Construct a Single-Sample Predictor Hybrid Object from Coefficients
#'
#' Reconstructs a \code{predictor_hybrid} object representing one observation, using a numeric
#' coefficient vector. This alternative constructor maps the coefficients back into their functional
#' and scalar predictor representations based on the structure of a template \code{predictor_hybrid} object.
#'
#' @param format A \code{predictor_hybrid} object that provides the structure and basis information.
#' @param coef A numeric vector containing coefficients for both functional and scalar predictors.
#'
#' @return A \code{predictor_hybrid} object with updated \code{functional_list}, \code{Z}, and \code{n_sample = 1}.
#'
#'
#' @export
predictor_hybrid_from_coef <- function(format, coef){
  M <- dim(format$gram_list[[1]])[2] # number of basis functions
  K <- length(format$functional_list) # number of functional predictors
  for (ii in 1:K){
    format$functional_list[[ii]] <- fd(
      coef = as.matrix(coef[((ii-1)*M + 1):(ii*M)]),
      basisobj = format$functional_list[[ii]]$basis
    )
  }
  format$Z <- t(as.matrix(coef[(K * M + 1):length(coef)]))
  format$n_sample <- 1
  return(format)
}
```

**unit test**
```{r}
testthat::test_that("hybrid_from_coef reconstructs single-sample predictor_hybrid correctly", {
  suppressPackageStartupMessages(library(fda))

  make_fd <- function(coefs, basis) {
    fd(coef = coefs, basisobj = basis)
  }

  basis <- create.bspline.basis(c(0, 1), nbasis = 4)
  n_sample <- 5
  n_scalar <- 2
  n_functional <- 2

  # Create dummy functional list with zeros
  fd1 <- make_fd(matrix(0, 4, n_sample), basis)
  fd2 <- make_fd(matrix(0, 4, n_sample), basis)
  Z <- matrix(0, n_sample, n_scalar)
  obj_template <- predictor_hybrid(Z = Z, functional_list = list(fd1, fd2))

  # Create coefficient vector for reconstruction: 4 + 4 + 2 = 10
  xi_star <- c(1:10)

  # Apply reconstruction
  obj_single <- predictor_hybrid_from_coef(obj_template, xi_star)

  # Checks
  testthat::expect_s3_class(obj_single, "predictor_hybrid")
  testthat::expect_equal(obj_single$n_sample, 1)
  testthat::expect_equal(obj_single$Z, matrix(c(9, 10), nrow = 1))

  # Check functional coefficients (use coef() not $coefs)
  testthat::expect_equal(drop(coef(obj_single$functional_list[[1]])), 1:4)
  testthat::expect_equal(drop(coef(obj_single$functional_list[[2]])), 5:8)
})

```

## Basic arithmetic

### add.predictor_hybrid
Performs element-wise addition of two `predictor_hybrid` objects.  Functional predictors are combined using `plus.fd()` and `times.fd()` from the `fda` package.

- Usage

```r
add.predictor_hybrid(input, other, alpha = 1)
```

- Arguments:

  - `input`: A `predictor_hybrid` object.
  - `other`: Another `predictor_hybrid` object to be added.
  - `alpha`: A scalar multiplier applied to `other` before addition (default is 1).

- Value:
Returns a new `predictor_hybrid` object representing the result of the addition.

- Details: 
  - This function assumes both objects have the same number and structure of functional and scalar predictors.  
  - Functional parts are scaled by `alpha` using `times.fd()` and then summed using `plus.fd()`.  
  - Scalar predictors are added using standard matrix addition.

```{r}
add.predictor_hybrid <- function(xi_1, xi_2, alpha = 1) {
  # Safe access to is.eqbasis()
  is_eqbasis <- getFromNamespace("is.eqbasis", "fda")

  for (i in seq_len(xi_1$n_functional)) {
    if (!is_eqbasis(xi_1$functional_list[[i]]$basis, xi_2$functional_list[[i]]$basis)) {
      stop("Functional predictors must have the same basis.")
    }
  }
  
   # Type checks
  if (!inherits(xi_1, "predictor_hybrid") || !inherits(xi_2, "predictor_hybrid")) {
    stop("Both inputs must be of class 'predictor_hybrid'.")
  }

  # Structural checks
  if (xi_1$n_functional != xi_2$n_functional) {
    stop("Mismatch in number of functional predictors.")
  }
  if (xi_1$n_scalar != xi_2$n_scalar) {
    stop("Mismatch in number of scalar predictors.")
  }

  # Swap so that broadcasting always applies to xi_2
  if (xi_1$n_sample == 1 && xi_2$n_sample > 1) {
    tmp <- xi_1
    xi_1 <- xi_2
    xi_2 <- tmp
  }

  n1 <- xi_1$n_sample
  n2 <- xi_2$n_sample

  if (!(n1 == n2 || n2 == 1)) {
    stop("Sample sizes are incompatible for broadcasting.")
  }

  # Prepare components
  f1 <- xi_1$functional_list
  f2 <- xi_2$functional_list
  Z1 <- xi_1$Z
  Z2 <- xi_2$Z

  # Replicate fd and Z if needed
  if (n2 == 1) {
    f2 <- rep_fd(f2, n1)
    Z2 <- matrix(rep(c(Z2), n1), nrow = n1, byrow = TRUE)
  }

  # Combine functional predictors
  new_functional_list <- Map(
    function(f1, f2) plus.fd(f1, times.fd(alpha, f2)),
    f1,
    f2
  )
 

  # Compute scalar inner products
  inprod_scalar <- rowSums(Z1 * Z2) 
  # Combine scalar predictors
  new_Z <- Z1 + alpha * Z2


  # Construct new object
  predictor_hybrid(Z = new_Z, functional_list = new_functional_list)
}
```

Here are the unit tests:
| Case                    | Description                         | Expected Outcome |
| ----------------------- | ----------------------------------- | ---------------- |
| ✅ Same sample size      | Functional and scalar values summed | Pass             |
| ✅ Broadcast one → many  | One-sample input broadcasted        | Pass             |
| ✅ Broadcast many ← one  | One-sample other broadcasted        | Pass             |
| ❌ Basis mismatch        | Different functional basis          | Error            |
| ❌ Irregular sample size | Neither matches nor is singleton    | Error            |
| ❌ Different dimensions  | Functional or scalar count mismatch | Error            |
```{r}
testthat::test_that("add.predictor_hybrid handles broadcasting and basis compatibility", {
  suppressPackageStartupMessages(library(fda))

  # Create shared B-spline basis
  basis <- create.bspline.basis(c(0, 1), nbasis = 5)

  # Helper to generate a valid coefficient matrix
  coef_mat <- function(val, n_sample, basis_obj) {
    nbasis <- basis_obj$nbasis
    matrix(val, nrow = nbasis, ncol = n_sample)
  }

  # Helper to create a list of fd objects (2 functional predictors)
  fd_list <- function(val, n_sample, basis_obj = basis) {
    list(
      fd(coef = coef_mat(val, n_sample, basis_obj), basisobj = basis_obj),
      fd(coef = coef_mat(val, n_sample, basis_obj), basisobj = basis_obj)
    )
  }

  # Scalar predictors
  Z1 <- matrix(1, nrow = 1, ncol = 2)
  Z3 <- matrix(3, nrow = 3, ncol = 2)

  # Functional predictors (same basis)
  F1 <- fd_list(1, 1)
  F3 <- fd_list(3, 3)

  # Create predictor_hybrid objects
  x1 <- predictor_hybrid(Z1, F1)  # 1 sample
  x3 <- predictor_hybrid(Z3, F3)  # 3 samples

  # Broadcast x1 to match x3
  result <- add.predictor_hybrid(x1, x3, alpha = 1)

  # Check metadata
  testthat::expect_s3_class(result, "predictor_hybrid")
  testthat::expect_equal(result$n_sample, 3)
  testthat::expect_equal(result$n_scalar, 2)
  testthat::expect_equal(result$n_functional, 2)

  # Check scalar component
  expected_Z <- matrix(4, nrow = 3, ncol = 2)  # 1 + 3 = 4
  testthat::expect_equal(result$Z, expected_Z)

  # Check functional component
  for (fd_out in result$functional_list) {
    testthat::expect_equal(unname(coef(fd_out)), matrix(4, nrow = 5, ncol = 3))
  }

  # Test symmetry: broadcasting x3 + x1
  result2 <- add.predictor_hybrid(x3, x1, alpha = 1)
  testthat::expect_equal(result2$Z, expected_Z)
  for (fd_out in result2$functional_list) {
    testthat::expect_equal(unname(coef(fd_out)), matrix(4, nrow = 5, ncol = 3))
  }

  # Incompatible sample sizes (should fail)
  x_bad <- predictor_hybrid(matrix(1, 2, 2), fd_list(1, 2))
  testthat::expect_error(add.predictor_hybrid(x3, x_bad), "incompatible for broadcasting")

  # Incompatible functional basis (should fail)
  bad_basis <- create.bspline.basis(c(0, 1), nbasis = 6)
  bad_fd <- fd_list(2, 3, bad_basis)
  x_basis_mismatch <- predictor_hybrid(Z3, bad_fd)
  testthat::expect_error(add.predictor_hybrid(x3, x_basis_mismatch), "same basis")
})

```
### subtr.predictor_hybrid
Performs element-wise subtraction of two `predictor_hybrid` objects.   Internally uses `add.predictor_hybrid(input, other, alpha = -1)` to compute the result by negating the second operand.

- Usage

```r
subtr.predictor_hybrid(input, other, alpha = 1)
```

- Arguments:

  - `input`: A `predictor_hybrid` object.
  - `other`: Another `predictor_hybrid` object to be subtracted.
  - `alpha`: A scalar multiplier applied to `other` before subtraction (default is 1).

- Value:  
Returns a new `predictor_hybrid` object representing the result of the subtraction.

- Details:  
  - This function assumes both objects have the same number and structure of functional and scalar predictors.  
  - It performs subtraction by internally calling `add.predictor_hybrid()` with `-alpha`.  
  - Functional parts are scaled using `times.fd()` and subtracted via `plus.fd()` with a negated factor.  
  - Scalar predictors are subtracted using standard matrix arithmetic.

```{r}
#' Subtract two predictor_hybrid objects
#'
#' Performs element-wise subtraction of two `predictor_hybrid` objects.
#' Internally uses `add.predictor_hybrid(input, other, alpha = -1)`.
#'
#' @param input A `predictor_hybrid` object.
#' @param other Another `predictor_hybrid` object to subtract.
#' @param alpha A scalar multiplier applied to `other` before subtraction (default is 1).
#'
#' @return A new `predictor_hybrid` object representing the result of subtraction.
#' @export
subtr.predictor_hybrid <- function(input, other, alpha = 1) {
  add.predictor_hybrid(input, other, alpha = -alpha)
}

```
We skip the unit test for this function.


### scalar_mul.predictor_hybrid
Multiplies all components of a `predictor_hybrid` object by a scalar. Functional components are scaled using `times.fd()` from the `fda` package, and scalar predictors are multiplied directly using matrix operations.

- Usage

```r
scalar_mul.predictor_hybrid(input, scalar)
```

- Arguments:

  - `input`: A `predictor_hybrid` object.
  - `scalar`: A numeric value used to scale both scalar and functional components.

- Value:  
Returns a new `predictor_hybrid` object with all components scaled by `scalar`.

- Details:  
  - Functional predictors are scaled using `times.fd(scalar, fd_obj)` for each element.  
  - Scalar predictors (the matrix `Z`) are scaled elementwise using matrix multiplication.

```{r}
#' Multiply a predictor_hybrid object by a scalar
#'
#' Performs scalar multiplication on both the scalar and functional components
#' of a `predictor_hybrid` object. Functional predictors are scaled using 
#' `times.fd()` from the `fda` package.
#'
#' @param input A `predictor_hybrid` object.
#' @param scalar A numeric value to multiply all components by.
#'
#' @return A new `predictor_hybrid` object scaled by `scalar`.
#' @export
scalar_mul.predictor_hybrid <- function(input, scalar) {
  if (!inherits(input, "predictor_hybrid")) {
    stop("Input must be of class 'predictor_hybrid'.")
  }
  if (!is.numeric(scalar) || length(scalar) != 1) {
    stop("Scalar must be a single numeric value.")
  }

  # Scale functional components
  new_functional_list <- lapply(input$functional_list, function(fd_obj) {
    times.fd(scalar, fd_obj)
  })

  # Scale scalar predictors
  new_Z <- scalar * input$Z

  # Reconstruct hybrid object
  predictor_hybrid(
    Z = new_Z,
    functional_list = new_functional_list
  )
}
```

Here is a test code with two functional predictors:
```{r}
testthat::test_that("scalar_mul.predictor_hybrid works with two functional predictors", {
  suppressPackageStartupMessages(library(fda))
  
  # Scalar part (3 observations, 2 scalar predictors)
  Z <- matrix(2, nrow = 3, ncol = 2)

  # Functional part: shared B-spline basis
  basis <- create.bspline.basis(c(0, 1), nbasis = 5)
  fd1 <- fd(coef = matrix(2, nrow = 5, ncol = 3), basisobj = basis)
  fd2 <- fd(coef = matrix(2, nrow = 5, ncol = 3), basisobj = basis)

  # Construct hybrid object using new simplified constructor
  obj <- predictor_hybrid(Z = Z, functional_list = list(fd1, fd2))

  # Apply scalar multiplication
  scaled <- scalar_mul.predictor_hybrid(obj, scalar = 4)

  # Check class
  testthat::expect_s3_class(scaled, "predictor_hybrid")

  # Check scalar predictor was scaled
  testthat::expect_equal(scaled$Z, Z * 4)

  # Check each functional component's coefficients
  expected_coef <- matrix(8, nrow = 5, ncol = 3)
  for (fd_obj in scaled$functional_list) {
    testthat::expect_equal(
      unname(coef(fd_obj)),
      unname(expected_coef)
    )
  }
})
```
### inprod.predictor_hybrid
- The inner product of $f_1=(f_1^{(1)}, \ldots,f_1^{(K)})$ and $f_2=(f_2^{(1)}, \ldots,f_2^{(K)})$ in $\mathcal{F}$ is defined as 
$$\langle f_1, f_2\rangle_\mathcal{F} =  \sum_{k=1}^K \langle f_1^{(k)}, f_2^{(k)}\rangle_{L^2} = \sum_{k=1}^K \int_{\mathcal{T}_k} f_1^{(k)}(t_k) f_2^{(k)}(t_k) dt_k,$$ with norm 
$$\Vert f_1 \Vert_\mathcal{F} = \langle f_1,f_1 \rangle_\mathcal{F}^{1/2} = \{ \sum_{k=1}^K \int_{\mathcal{T}_k} f_1^{(k)}(t_k)^2 dt_k\}^{1/2}.$$
- We define the inner product between any two hybrid objects, $\mathbf{h}_1 = (f_1, \mathbf{v}_1)$ and $\mathbf{h}_2 = (f_2, \mathbf{v}_2)$, as
$$
    \langle \mathbf{h}_1, \mathbf{h}_2\rangle_{\mathcal{H}} = \langle f_1, f_2\rangle_\mathcal{F} +  \langle  \mathbf{v_1}, \mathbf{v_2} \rangle = \sum \limits_{k=1}^K \int_{\mathcal{T}_k} f_1^{(k)}(t_k) f_2^{(k)}(t_k) dt_k + \sum \limits_{r=1}^p v_{1r}v_{2r}, 
$$
with norm $\Vert \cdot \Vert_\mathcal{H} = \langle \cdot,\cdot \rangle_\mathcal{H}^{1/2}$. 

- The method `inprod.predictor_hybrid` computes the inner product between two `predictor_hybrid` objects. It supports broadcasting when one of the inputs has a single observation.


- Usage

```r
inprod.predictor_hybrid(xi_1, xi_2)
```

- Arguments:

  - `xi_1`: A `predictor_hybrid` object.
  - `xi_2`: Another `predictor_hybrid` object. If omitted, defaults to xi_1 (computes self-inner product).

- Value:  A numeric vector of inner products (or a scalar if both inputs are single observations).

- Details:  
  - Functional components are summed using inprod() from the fda package.
  - Scalar components are handled via matrix multiplication.
  - Broadcasting is supported: if either xi_1 or xi_2 has only one sample, its values are broadcast across all rows of the other.
  - Ensures compatibility in the number of functional and scalar predictors before computing the result.
```{r}
#' Inner product between two predictor_hybrid objects (with broadcasting)
#'
#' Computes the inner product between two `predictor_hybrid` objects,
#' including both functional and scalar components. Supports broadcasting
#' when one of the inputs has a single observation.
#'
#' @param xi_1 A `predictor_hybrid` object.
#' @param xi_2 Another `predictor_hybrid` object. If missing, defaults to `xi_1`.
#'
#' @return A numeric vector of inner products, or a scalar if both inputs contain a single observation.
#' @export
inprod.predictor_hybrid <- function(xi_1, xi_2 = NULL) {
  # Handle self-inner product
  if (is.null(xi_2)) xi_2 <- xi_1 
  
  # Type checks
  if (!inherits(xi_1, "predictor_hybrid") || !inherits(xi_2, "predictor_hybrid")) {
    stop("Both inputs must be of class 'predictor_hybrid'.")
  }

  # Structural checks
  if (xi_1$n_functional != xi_2$n_functional) {
    stop("Mismatch in number of functional predictors.")
  }
  if (xi_1$n_scalar != xi_2$n_scalar) {
    stop("Mismatch in number of scalar predictors.")
  }

  # Swap so that broadcasting always applies to xi_2
  if (xi_1$n_sample == 1 && xi_2$n_sample > 1) {
    tmp <- xi_1
    xi_1 <- xi_2
    xi_2 <- tmp
  }

  n1 <- xi_1$n_sample
  n2 <- xi_2$n_sample

  if (!(n1 == n2 || n2 == 1)) {
    stop("Sample sizes are incompatible for broadcasting.")
  }

  # Prepare components
  f1 <- xi_1$functional_list
  f2 <- xi_2$functional_list
  Z1 <- xi_1$Z
  Z2 <- xi_2$Z

  # Replicate fd and Z if needed
  if (n2 == 1) {
    f2 <- rep_fd(f2, n1)
    Z2 <- matrix(rep(c(Z2), n1), nrow = n1, byrow = TRUE)
  }

  # Compute functional inner products
  inprod_functional <- vapply(seq_len(n1), function(i) {
    sum(vapply(seq_along(f1), function(j) {
      fda::inprod(f1[[j]][i], f2[[j]][i])
    }, numeric(1)))
  }, numeric(1))
 

  # Compute scalar inner products
  inprod_scalar <- rowSums(Z1 * Z2) 
 
  # Combine results
  result <- inprod_functional + inprod_scalar
  if (n1 == 1 && n2 == 1) as.numeric(result) else result
}
```

We run unit tests for:

| Case | Description                        | Input Dimensions       | Output Length | Notes                                           |
|------|------------------------------------|------------------------|----------------|-------------------------------------------------|
| 1    | Self inner product (1 sample)      | x2: (1×2)              | 1              | Equivalent to squared norm                     |
| 2    | Three-sample vs. Three-sample      | x1: (3×2), x3: (3×2)   | 3              | Dot + functional products, sample-wise         |
| 3    | One-sample vs. One-sample          | x2: (1×2), x4: (1×2)   | 1              | Standard dot + functional product              |
| 4    | Broadcasting (single vs. multi)    | x2: (1×2), x3: (3×2)   | 3              | Broadcast x2 across x3                          |
| 5    | Broadcasting (multi vs. single)    | x3: (3×2), x2: (1×2)   | 3              | Broadcast x2 across x3                          |


```{r}
testthat::test_that("inprod.predictor_hybrid returns correct vector output for broadcasting and other cases", {
  suppressPackageStartupMessages(library(fda))

  basis <- create.bspline.basis(c(0, 1), 5)
  make_fd <- function(val, n_sample) {
    fd(coef = matrix(val, 5, n_sample), basisobj = basis)
  }
# data generation
## three observations
  fd1 <- make_fd(1, 3)
  Z1 <- matrix(c(1, 2), nrow = 3, ncol = 2, byrow = TRUE)
  x1 <- predictor_hybrid(Z1, list(fd1, fd1))
## one observation
  fd2 <- make_fd(2, 1)
  Z2 <- matrix(c(3, 4), nrow = 1)
  x2 <- predictor_hybrid(Z2, list(fd2, fd2))
## three observations
  Z3 <- matrix(c(1, 2, 3, 4, 5, 6), nrow = 3, byrow = TRUE)
  fd3 <- fd(coef = t(matrix(c(1:15), nrow = 3, byrow = TRUE)), basisobj = basis)
  x3 <- predictor_hybrid(Z3, list(fd3, fd3))  
## one observations
  Z4 <- matrix(c(5, 6), nrow = 1)
  fd4 <- make_fd(3, 1)
  x4 <- predictor_hybrid(Z4, list(fd4, fd4))
  
# Case 1: Self inner product (1 sample)
  out1 <- inprod.predictor_hybrid(x2)
  expected_scalar_1 <- sum(Z2^2)
  expected_functional_1 <- sum(sapply(x2$functional_list, function(fd) fda::inprod(fd, fd)))
  testthat::expect_equal(out1, expected_scalar_1 + expected_functional_1)

# Case 2: Three-sample vs. Three-sample
  out2 <- inprod.predictor_hybrid(x1, x3)
  expected_scalar_2 <- rowSums(Z1 * Z3)
  expected_functional_2 <- vapply(1:3, function(i) {
    sum(sapply(1:2, function(j) {
      fda::inprod(x1$functional_list[[j]][i], x3$functional_list[[j]][i])
    }))
  }, numeric(1))
  testthat::expect_equal(out2, expected_scalar_2 + expected_functional_2)
  
  # Case 3: One-sample vs. one-sample

  out3 <- inprod.predictor_hybrid(x2, x4)
  expected_scalar_3 <- sum(Z2 * Z4)
  expected_functional_3 <-2*fda::inprod(fd2, fd4)
  testthat::expect_equal(out3, as.numeric(expected_scalar_3 + expected_functional_3))


  # Case 4: Broadcasting (single vs. multi)
  out4 <- inprod.predictor_hybrid(x2, x3)
  expected_scalar_4 <- c(0,0,0)
  for (i in 1:3){
    expected_scalar_4[i] <-  sum(Z2 * Z3[i,])
    }

  expected_functional_4 <-  c(0,0,0)
  for (i in 1:3){
    expected_functional_4[i] <- 2*fda::inprod(
      fd2,
      fd(
        coef = matrix(
        c(
        (5*i+1-5):(5*i)
        ), 5, 1), #end of matrix
         basisobj = basis) #end of fd
      )# end of inprod
  }

  testthat::expect_equal(as.vector(out4), as.vector(expected_scalar_4 + expected_functional_4))

  # Case 4: Broadcasting (multi  vs. single)
  testthat::expect_equal(as.vector(inprod.predictor_hybrid( x3, x2)), as.vector(expected_scalar_4 + expected_functional_4))  
})
```

# One iteration

## small functions



## penalty matrix construction
In this section, we provide an R function `get_constraint_matrix` that constructs the penalty matrix
$$J^*+\Lambda \ddot{J}^\ast,$$
as defined in Proposition 2 and used in the PLS component computation step of our proposed algorithm. We present functions  for computing $J^\ast$, $\Lambda$ and $\ddot{J}^\ast$ in sequence, and use these functions to define `get_constraint_matrix`.

### get_gram_matrix_block
Constructs a block-diagonal Gram matrix for a hybrid predictor object, defined as 
$$
    J^*=\mathrm{blkdiag}(J, I_p) \in \mathbb{R}^{(MK+p) \times (MK+p)}
$$
where
 $J = \mathrm{blkdiag}(J^{(1)}, \cdots, J^{(K)}) \in \mathbb{R}^{MK \times MK}$, and 
$$
J^{(k)} = \left[ \int_{\mathcal{T}k} b_m^{(k)}(t) , b_n^{(k)}(t) , dt \right]_{m,n=1}^M,
$$
as defined in \eqref{def:gram_basis} and \eqref{def:J_and_J_star}.

- Arguments
  - obj: A `predictor_hybrid` object containing both functional and scalar components.

- Value
  - A Matrix::bdiag sparse matrix representing the block-diagonal structure of the combined Gram matrix.

- Details: This function builds a block-diagonal matrix by:
  - Stacking the Gram matrices of each functional component (from obj$gram_list),
  - Appending an identity matrix of size equal to the number of scalar predictors (to represent unpenalized scalar covariates).
  The resulting matrix has size $(\texttt{total_dim} \times \texttt{total_dim})$, where total_dim = \sum_k M_k + p, with $M_k$ the number of basis functions for the $k$-th functional predictor and $p$ the number of scalar covariates.
  
- Usage
```r
block_gram <- get_gram_matrix_block(my_predictor)
```


**Code**
```{r}
#' Construct block-diagonal Gram matrix for hybrid predictor
#'
#' Returns a block-diagonal matrix containing the Gram  matrices for
#' each functional component and an identity matrix for the scalar part.
#'
#' @param obj A `predictor_hybrid` object.
#'
#' @return A block-diagonal matrix of size `(total_dim × total_dim)` where
#' functional and scalar components are arranged in order.
#' @export
get_gram_matrix_block <- function(obj) {
  if (!inherits(obj, "predictor_hybrid")) {
    stop("Input must be of class 'predictor_hybrid'.")
  }

  gram_blocks <- c(obj$gram_list, list(diag(obj$n_scalar)))
  Matrix::bdiag(gram_blocks)
}

```

**Unit test**
```{r}
testthat::test_that("get_gram_matrix_block constructs correct block-diagonal matrix", {
  suppressPackageStartupMessages(library(fda))
  suppressPackageStartupMessages(library(Matrix))

  # Construct hybrid predictor with two functional and three scalar predictors
  basis1 <- create.bspline.basis(c(0, 1), nbasis = 4)
  basis2 <- create.bspline.basis(c(0, 1), nbasis = 4)  # was 3; now valid

  fd1 <- fd(coef = matrix(1, 4, 2), basisobj = basis1)
  fd2 <- fd(coef = matrix(2, 4, 2), basisobj = basis2)
  Z <- matrix(rnorm(2 * 3), nrow = 2, ncol = 3)

  obj <- predictor_hybrid(Z = Z, functional_list = list(fd1, fd2))

  # Extract the block-diagonal Gram matrix
  G <- get_gram_matrix_block(obj)

  # Expected block sizes
  nb1 <- 4
  nb2 <- 4
  ns <- 3
  total_dim <- nb1 + nb2 + ns

  # Check matrix properties
  testthat::expect_equal(dim(G), c(total_dim, total_dim))

  # Check sub-block structure
  # Top-left: Gram matrix 1
  testthat::expect_equal(sum(G[1:nb1, 1:nb1]-obj$gram_list[[1]]), 0)

  # Next block: Gram matrix 2
  testthat::expect_equal(sum( G[(nb1 + 1):(nb1 + nb2), (nb1 + 1):(nb1 + nb2)]-obj$gram_list[[2]]),0 )

  # Final block: identity matrix for scalar part
  testthat::expect_equal( sum( G[(nb1 + nb2 + 1):total_dim, (nb1 + nb2 + 1):total_dim]  - diag(ns)), 0)
})

```
### get_smoothing_param_hybrid
Constructs a block-diagonal smoothing parameter matrix for use in penalized estimation involving hybrid predictors, denoted $\Lambda \in \mathbb{R}^{(MK+p) \times (MK+p)}$,  defined in \eqref{def:Lambda} as
$$
   \Lambda = \mathrm{blkdiag}(\lambda_1 I_M, \cdots, \lambda_K I_M, 0_{p \times p}) , 
$$

- Arguments
  - W: A predictor_hybrid object.
  - lambda: A numeric vector of length equal to the number of functional predictors. Each entry corresponds to a smoothing penalty weight.
- Value: A sparse block-diagonal matrix combining scaled identity matrices for the functional parts and a zero matrix for the scalar part.
- Details: This function generates a matrix used in regularized regression for functional predictors. Each functional component is penalized using a scaled identity matrix of its basis dimension. Scalar predictors are unpenalized.
- Usage:
```r
lambda_mat <- get_smoothing_param_hybrid(my_predictor, c(0.1, 0.2))
```
**code** 
```{r}
#' Construct block-diagonal smoothing parameter matrix
#'
#' Generates a block-diagonal matrix with smoothing parameters applied to each 
#' functional component. Each block is a scaled identity matrix, where the scaling 
#' factor corresponds to the regularization parameter for that functional component. 
#' The scalar components are not penalized and thus contribute a zero matrix block.
#'
#' @param W A `predictor_hybrid` object.
#' @param lambda A numeric vector of length equal to the number of functional components (`W$n_functional`), containing the smoothing parameters for each functional predictor.
#'
#' @return A block-diagonal matrix of size `(total_dim × total_dim)`, where the top-left blocks are scaled identity matrices for functional predictors and the bottom-right block is a zero matrix for scalar covariates.
#' @export
get_smoothing_param_hybrid <- function(W, lambda) {
  if (!inherits(W, "predictor_hybrid")) {
    stop("Input W must be of class 'predictor_hybrid'.")
  }

  if (length(lambda) != W$n_functional) {
    stop("Length of lambda must match the number of functional predictors.")
  }

  lambda_blocks <- lapply(seq_len(W$n_functional), function(ii) {
    nb <- W$functional_list[[ii]]$basis$nbasis
    lambda[ii] * diag(nb)
  })

  lambda_blocks[[W$n_functional + 1]] <- matrix(0, nrow = W$n_scalar, ncol = W$n_scalar)

  Matrix::bdiag(lambda_blocks)
}
```

**unit test**
```{r}
testthat::test_that("get_smoothing_param_hybrid returns correct block-diagonal structure", {
  suppressPackageStartupMessages(library(fda))
  basis1 <- create.bspline.basis(c(0, 1), nbasis = 5)
  basis2 <- create.bspline.basis(c(0, 1), nbasis = 4)

  fd1 <- fd(coef = matrix(1, 5, 3), basisobj = basis1)
  fd2 <- fd(coef = matrix(2, 4, 3), basisobj = basis2)

  Z <- matrix(1, nrow = 3, ncol = 2)

  obj <- predictor_hybrid(Z = Z, functional_list = list(fd1, fd2))
  lambda <- c(0.5, 2)

  lambda_mat <- get_smoothing_param_hybrid(obj, lambda)

  # Check overall dimension
  expected_dim <- sum(obj$n_basis_list) + obj$n_scalar
  testthat::expect_equal(dim(lambda_mat), c(expected_dim, expected_dim))

  # Check diagonal entries
  testthat::expect_equal(Matrix::diag(lambda_mat)[1:5], rep(0.5, 5))
  testthat::expect_equal(Matrix::diag(lambda_mat)[6:9], rep(2, 4))
  testthat::expect_equal(Matrix::diag(lambda_mat)[10:11], rep(0, 2))  # scalar part
})

```


### get_penalty_hybrid
Constructs a matrix defined in \label{def:J_dotdot_ast}
$$
    \ddot{J}^\ast=\mathrm{blkdiag}(\ddot{J}^{(1)}, \cdots, \ddot{J}^{(K)}, 0_{p \times p}) \in \mathbb{R}^{(MK+p) \times (MK+p)},
$$
where
 $\ddot{J}^{(k)}$ is  a $M \times M$ matrix defined in \label{def:dodot_J_k} as the gram matrix formed by the second derivativ of the basis functions
$$
\ddot{J}^{(k)} = \left[ \int_{\mathcal{T}_k} \ddot{b}^{(k)}_m(t) \ddot{b}^{(k)}_n(t) \, dt \right]_{m,n=1}^M.
$$
```{r}
#' Construct the roughness penalty matrix for a predictor_hybrid object
#'
#' Returns a block diagonal matrix representing roughness penalties for each functional predictor
#' and zeros for the scalar predictors (scalar predictors are not penalized). Each functional component uses its own basis penalty matrix, computed via second derivative penalty via `getbasispenalty()` from the `fda` package
#'
#' @param W A `predictor_hybrid` object.
#'
#' @return A block diagonal penalty matrix of dimension `(sum(n_basis_list) + n_scalar)^2`.
#' @export
get_penalty_hybrid <- function(W){
  J_dotdot_star <- fda::getbasispenalty(W$functional_list[[1]]$basis)
  for (ii in 2:(W$n_functional)){
    J_dotdot_star <- Matrix::bdiag(
      J_dotdot_star,
      fda::getbasispenalty(W$functional_list[[ii]]$basis)
    )
    }
  J_dotdot_star <- Matrix::bdiag(
    J_dotdot_star,
    matrix(0, nrow = W$n_scalar, ncol = W$n_scalar)
    )
  return(J_dotdot_star)
  }
```


```{r}
testthat::test_that("get_penalty_hybrid computes correct dimensions and structure", {
  suppressPackageStartupMessages(library(fda))

  # Setup
  basis <- fda::create.bspline.basis(c(0, 1), nbasis = 5)
  n_sample <- 3
  n_scalar <- 2

  fd1 <- fda::fd(coef = matrix(1, 5, n_sample), basisobj = basis)
  fd2 <- fda::fd(coef = matrix(2, 5, n_sample), basisobj = basis)
  Z <- matrix(rnorm(n_sample * n_scalar), n_sample, n_scalar)
  obj <- predictor_hybrid(Z = Z, functional_list = list(fd1, fd2))

  # Run
  penalty <- get_penalty_hybrid(obj)

  # Expected dimensions
  total_dim <- sum(obj$n_basis_list) + obj$n_scalar
  testthat::expect_equal(dim(penalty), c(total_dim, total_dim))

  # Check block diagonal structure: bottom-right should be zero matrix
  scalar_block <- as.matrix(penalty[
    (total_dim - n_scalar + 1):total_dim,
    (total_dim - n_scalar + 1):total_dim
  ])
  testthat::expect_equal(scalar_block, matrix(0, n_scalar, n_scalar))

  # Check that the upper blocks are positive semidefinite
  eigenvalues <- eigen(as.matrix(penalty[1:(total_dim - n_scalar), 1:(total_dim - n_scalar)]))$values
  testthat::expect_true(all(eigenvalues >= -1e-8))  # Numerical tolerance
})

```

### get_constraint_matrix

```r
W <- predictor_hybrid(Z = Z, functional_list = list(fd1, fd2))
lambda <- c(0.1, 0.2)
constraint_matrix <- get_constraint_matrix_hybrid(W, lambda)
```

**code**
```{r}
#' Construct penalized constraint matrix for hybrid predictors
#'
#' Computes the denominator matrix used in penalized estimation for hybrid predictors,
#' combining the Gram matrix, smoothing parameter matrix, and penalty matrix.
#'
#' Specifically, this function returns the matrix:
#' \deqn{J^\ast + \Lambda \ddot{J}^\ast}
#' where \eqn{J^\ast} is the block-diagonal Gram matrix,
#' \eqn{\Lambda} is the block-diagonal smoothing parameter matrix,
#' and \eqn{\ddot{J}^\ast} is the block-diagonal penalty matrix of second derivative inner products.
#'
#' @param W A `predictor_hybrid` object.
#' @param lambda A numeric vector of smoothing parameters, one for each functional predictor.
#'
#' @return A matrix representing the penalized constraint matrix used in estimation.
#' @export
get_constraint_matrix_hybrid <- function(W, lambda) {
  J_star <- get_gram_matrix_block(W)
  J_dotdot_star <- get_penalty_hybrid(W)
  lambda_mat <- get_smoothing_param_hybrid(W, lambda)

  J_star + lambda_mat %*% J_dotdot_star
}

```

## asd
### get_pre_corrcov
construct the matrix V_star:
$$
    V^\ast = n^{-2}\begin{bmatrix}
         J \widetilde{C}^\top \mathbf{y}\mathbf{y}^\top \widetilde{C} J & J \widetilde{C}^\top \widetilde{\mathbf{y}} \widetilde{\mathbf{y}}^\top \widetilde{Z} \\
        \widetilde{Z}^\top \widetilde{\mathbf{y}} \widetilde{\mathbf{y}}^\top \widetilde{C} J &   \widetilde{Z}^\top \widetilde{\mathbf{y}} \widetilde{\mathbf{y}}^\top \widetilde{Z}
    \end{bmatrix} = n^{-2} J^* \widetilde{C}^{*\top} \widetilde{\mathbf{y}} \widetilde{\mathbf{y}}^\top \widetilde{C}^{*} J^*
    \in \mathbb{R}^{(MK+p) \times (MK+p)},
$$
where $J$ is defined in `get_gram_matrix_block`
equation (7), 
```{r}
#' Compute V matrix (pre-corrected covariance estimator)
#'
#' Constructs the V matrix involving inner products of functional predictors
#' (weighted by their Gram matrices) and scalar predictors against response y.
#'
#' @param W A `predictor_hybrid` object.
#' @param y A numeric response vector of length equal to number of samples.
#'
#' @return A matrix representing the corrected cross-covariance structure.
#' @export
get_pre_corrcov <- function(W, y){
  n <- W$n_sample
  K <- W$n_functional

  # building blocks
  ## C_J : C multiplied by J. Scalable to arbitrary K
  predictor_first <- W$functional_list[[1]]
  C_J <- t(predictor_first$coefs) %*% W$gram_list[[1]]
  for (i in 2:K){
    predictor_now <- W$functional_list[[i]]
    C_J <- cbind(
      C_J,
      t(predictor_now$coefs) %*% W$gram_list[[i]]
    )
    }

  
  ## covariance
  J_Ct_y <- t(C_J) %*% y
  Zt_y <- t(W$Z) %*% y

  # V matrix
  upper_left <- J_Ct_y %*% t(J_Ct_y)
  upper_right <- J_Ct_y %*% t(Zt_y)
  lower_left <- t(upper_right)
  lower_right <- Zt_y %*% t(Zt_y)

  V_star <- cbind(
    rbind(upper_left, lower_left),
    rbind(upper_right, lower_right)
    )/(n^2)

  return(V_star)
  }
```

test code:

| Case | Description               | Functional Coefficients         | Scalar Covariates      | Response         | Expected Behavior                              |
|------|---------------------------|----------------------------------|------------------------|------------------|------------------------------------------------|
| 1    | Constant structure        | All ones or twos                | All ones               | Increasing vector| Output matrix is symmetric and non-negative    |
| 2    | Random structure          | Random normal entries           | Random normal values   | Random vector    | Output is symmetric and numerically PSD        |


```{r}
testthat::test_that("get_pre_corrcov handles constant and random coefficients", {
  suppressPackageStartupMessages(library(fda))

  make_fd <- function(coefs, basis) {
    fd(coef = coefs, basisobj = basis)
  }

  basis <- create.bspline.basis(c(0, 1), nbasis = 4)
  n_sample <- 5
  n_scalar <- 2
  n_functional <- 2

  # Constant coefficients
  fd_const1 <- make_fd(matrix(1, 4, n_sample), basis)
  fd_const2 <- make_fd(matrix(2, 4, n_sample), basis)
  Z_const <- matrix(1, n_sample, n_scalar)
  y_const <- matrix(1:n_sample, ncol = 1)
  obj_const <- predictor_hybrid(Z = Z_const, functional_list = list(fd_const1, fd_const2))

  V_const <- get_pre_corrcov(obj_const, y_const)
  testthat::expect_equal(dim(V_const), rep(sum(obj_const$n_basis_list) + obj_const$n_scalar, 2))
  testthat::expect_true(isSymmetric(V_const))
  testthat::expect_true(all(V_const >= 0))

  # Random coefficients
  set.seed(123)
  fd_rand1 <- make_fd(matrix(rnorm(4 * n_sample), 4, n_sample), basis)
  fd_rand2 <- make_fd(matrix(rnorm(4 * n_sample), 4, n_sample), basis)
  Z_rand <- matrix(rnorm(n_sample * n_scalar), n_sample, n_scalar)
  y_rand <- matrix(rnorm(n_sample), ncol = 1)
  obj_rand <- predictor_hybrid(Z = Z_rand, functional_list = list(fd_rand1, fd_rand2))

  V_rand <- get_pre_corrcov(obj_rand, y_rand)
  testthat::expect_equal(dim(V_rand), rep(sum(obj_rand$n_basis_list) + obj_rand$n_scalar, 2))
  testthat::expect_true(isSymmetric(V_rand))
  testthat::expect_true(all(eigen(V_rand, only.values = TRUE)$values >= -1e-8))
})

```







## Documenting the package and building

We finish by running commands that will document, build, and install the package.  It may also be a good idea to check the package from within this file.

```{r}
litr::document() # <-- use instead of devtools::document()
# devtools::build()
# devtools::install()
# devtools::check(document = FALSE)
```


