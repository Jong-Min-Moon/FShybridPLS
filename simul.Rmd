---
title: "simulation"
output: html_document
date: "2025-12-29"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
# ==============================================================================
# SIMULATION: The Annihilation Property "Torture Test"
# Verifies: < W_resid[l+1], xi[l] >_H == 0 under extreme conditions
# ==============================================================================

library(fda)
library(ggplot2)
library(dplyr)
library(tidyr)

# ------------------------------------------------------------------------------
# 1. HELPER: EXACT INNER PRODUCT (Crucial for Verification)
# ------------------------------------------------------------------------------
exact_inprod <- function(W, xi) {
  # 1. Scalar Part
  scores <- as.matrix(W$Z) %*% t(as.matrix(xi$Z))
  
  # 2. Functional Part (Exact Integral via J matrix)
  for(k in seq_along(W$functional_list)) {
    fd_W  <- W$functional_list[[k]]
    fd_xi <- xi$functional_list[[k]]
    J <- fda::inprod(fd_W$basis, fd_W$basis)
    weighted_xi <- J %*% fd_xi$coefs
    scores <- scores + t(fd_W$coefs) %*% weighted_xi
  }
  return(as.vector(scores))
}

# ------------------------------------------------------------------------------
# 2. DATA GENERATION: "The Torture Chamber"
# ------------------------------------------------------------------------------
generate_torture_data <- function(n_sample = 100) {
  # A. Shared Latent Factors (Creates collinearity)
  t1 <- rnorm(n_sample, sd=10)
  t2 <- rnorm(n_sample, sd=0.1) # Tiny variance component
  
  eval_points <- seq(0, 1, length.out=100)
  basis <- create.bspline.basis(c(0,1), 15) # Higher basis dim
  
  # B. Functional Predictor 1: High Magnitude, Low Freq
  X1 <- outer(t1, sin(2*pi*eval_points)) 
  fd1 <- Data2fd(eval_points, t(X1), basis)
  
  # C. Functional Predictor 2: Low Magnitude, High Freq (Noise trap)
  X2 <- outer(t2, sin(10*pi*eval_points)) + matrix(rnorm(n_sample*100, sd=0.01), 100, n_sample)
  fd2 <- Data2fd(eval_points, t(X2), basis)
  
  # D. Scalars: 50 Variables, Rank Deficient (Rank ~ 2)
  Z_base <- matrix(rnorm(n_sample * 2), n_sample, 2)
  Z_noise <- matrix(rnorm(n_sample * 50, sd=0.001), n_sample, 50)
  # Mix: All 50 scalars depend on just 2 random vectors
  Z <- Z_base %*% matrix(rnorm(2*50), 2, 50) + Z_noise
  
  # E. Response
  y <- t1 * 0.5 + t2 * 10 + rnorm(n_sample)
  
  W_init <- predictor_hybrid(Z, list(fd1, fd2), eval_points)
  return(list(W = W_init, y = y))
}

# ------------------------------------------------------------------------------
# 3. RUN SIMULATION
# ------------------------------------------------------------------------------
set.seed(999)
data <- generate_torture_data(100)
processed <- split_and_normalize.all(data$W, data$y, train_ratio=0.99)

W_current <- processed$predictor_train
y_current <- processed$response_train

# TEST PARAMETERS
# We use different lambdas for different functions to stress the metric
lambda_vec <- c(10, 0.01) 
n_iter <- 5
results_df <- data.frame()

message("Running Torture Test (Exact Matrix Mode)...")

for(l in 1:n_iter) {
  
  # 1. Get Direction (Xi) - Penalized
  xi_current <- get_xi_hat_linear_pen(W_current, y_current, lambda_vec)
  
  # 2. Get Scores (Rho) -- EXACT
  rho_current <- exact_inprod(W_current, xi_current)
  
  # 3. Get Loadings (Delta)
  delta_current <- get_delta(W_current, rho_current) 
  nu_current    <- get_nu(y_current, rho_current)
  
  # 4. MEASURE SIGNAL BEFORE DEFLATION
  signal_mag <- sqrt(sum(exact_inprod(W_current, xi_current)^2))
  
  # 5. Deflate
  W_next <- residualize_predictor(W_current, rho_current, delta_current)
  y_next <- residualize_y(y_current, rho_current, nu_current)
  
  # 6. MEASURE LEAKAGE AFTER DEFLATION (The Proof Condition)
  leakage_vec <- exact_inprod(W_next, xi_current)
  leakage_mag <- sqrt(sum(leakage_vec^2))
  
  # 7. Log
  status <- ifelse(leakage_mag < 1e-9, "PASS", "FAIL")
  
  results_df <- rbind(results_df, data.frame(
    Iteration = l,
    Signal_Strength = signal_mag,
    Residual_Leakage = leakage_mag,
    Status = status
  ))
  
  cat(sprintf("Iter %d: Signal=%.2e | Leakage=%.2e | %s\n", 
              l, signal_mag, leakage_mag, status))
  
  W_current <- W_next
  y_current <- y_next
}

# ------------------------------------------------------------------------------
# 4. VISUALIZATION
# ------------------------------------------------------------------------------
cat("\n=======================================================\n")
cat("      TORTURE TEST RESULTS \n")
cat("=======================================================\n")
print(results_df)

df_long <- tidyr::pivot_longer(results_df, cols = c("Signal_Strength", "Residual_Leakage"))

ggplot(df_long, aes(x=factor(Iteration), y=value, fill=name)) +
  geom_bar(stat="identity", position=position_dodge()) +
  scale_y_continuous(trans="log10") +
  labs(title="Annihilation Torture Test",
       subtitle="Even with high collinearity and penalties, leakage must be ~0",
       y="Magnitude (Log10)",
       x="Iteration") +
  theme_minimal() +
  scale_fill_manual(values=c("firebrick", "steelblue")) +
  geom_hline(yintercept=1e-10, linetype="dashed")
```
```{r}
# ==============================================================================
# SIMULATION: Annihilation Audit (Using Modified fit.hybridPLS)
# ==============================================================================

library(fda)
library(ggplot2)
library(dplyr)
library(tidyr)

# ------------------------------------------------------------------------------
# 1. HELPER: EXACT INNER PRODUCT
# ------------------------------------------------------------------------------
# We use this to audit the result. It effectively replicates get_rho logic
# but ensures we control the inputs for verification.
audit_score_magnitude <- function(W, xi, J_list) {
  
  # 1. Scalar Part
  # (N x P) %*% (P x 1)
  scores <- as.matrix(W$Z) %*% t(as.matrix(xi$Z))
  
  # 2. Functional Part (Matrix Algebra)
  for(k in seq_along(W$functional_list)) {
    Theta_j <- t(W$functional_list[[k]]$coefs)
    gamma_j <- xi$functional_list[[k]]$coefs
    B_j     <- J_list[[k]]
    
    # Exact Integral: Theta * B * gamma
    scores <- scores + Theta_j %*% (B_j %*% gamma_j)
  }
  
  # Return L2 Norm (Magnitude)
  return(sqrt(sum(scores^2)))
}

# ------------------------------------------------------------------------------
# 2. DATA GENERATION
# ------------------------------------------------------------------------------
generate_torture_data <- function(n_sample = 100) {
  t1 <- rnorm(n_sample, sd=10)
  t2 <- rnorm(n_sample, sd=0.1) 
  
  eval_points <- seq(0, 1, length.out=100)
  basis <- create.bspline.basis(c(0,1), 15)
  
  X1 <- outer(t1, sin(2*pi*eval_points)) 
  fd1 <- Data2fd(eval_points, t(X1), basis)
  
  X2 <- outer(t2, sin(10*pi*eval_points)) + matrix(rnorm(n_sample*100, sd=0.01), 100, n_sample)
  fd2 <- Data2fd(eval_points, t(X2), basis)
  
  Z <- matrix(rnorm(n_sample * 50), n_sample, 50)
  y <- t1 * 0.5 + t2 * 10 + rnorm(n_sample)
  
  W_init <- predictor_hybrid(Z, list(fd1, fd2), eval_points)
  return(list(W = W_init, y = y))
}

# ------------------------------------------------------------------------------
# 3. RUN SIMULATION
# ------------------------------------------------------------------------------
set.seed(999)
data <- generate_torture_data(100)
processed <- split_and_normalize.all(data$W, data$y, train_ratio=0.99)
W_train <- processed$predictor_train
y_train <- processed$response_train

# PRE-CALCULATE GRAM MATRICES (Required for audit helper)
basis_obj <- W_train$functional_list[[1]]$basis
J_matrix  <- fda::inprod(basis_obj, basis_obj)
gram_list_audit <- list(J_matrix, J_matrix)

# A. RUN THE FIT (One Shot)
# ------------------------------------------------------------------------------
n_comp <- 5
message("Fitting model...")

# NOTE: We attach gram_list to input W in case your internal functions use it
W_train$gram_list <- gram_list_audit 

fit <- fit.hybridPLS(
  W = W_train, 
  y = y_train, 
  n_iter = n_comp, 
  lambda = c(10, 0.01)
)

# B. AUDIT THE STORED OBJECTS
# ------------------------------------------------------------------------------
message("Auditing stored W and Xi objects...")

results_df <- data.frame()

for(l in 1:n_comp) {
  
  # Retrieve Stored Objects directly from output
  W_before <- fit$W[[l]]      # Data used to find Component l
  W_after  <- fit$W[[l + 1]]  # Data AFTER Component l was removed (Stored in l+1)
  xi_current <- fit$xi[[l]]   # The direction found
  
  # Check 1: Signal Strength (Should be Large)
  # < W[l], xi[l] >
  signal_mag <- get_rho(W_before, xi_current)
  
  # Check 2: Annihilation / Leakage (Should be ZERO)
  # < W[l+1], xi[l] >
  leakage_mag <- get_rho(W_after, xi_current)
  
  # Log
  status <- ifelse(leakage_mag < 1e-2, "PASS", "FAIL")
  
  results_df <- rbind(results_df, data.frame(
    Iteration = l,
    Signal_Strength = signal_mag,
    Residual_Leakage = leakage_mag,
    Status = status
  ))
  
  cat(sprintf("Comp %d: Signal=%.2e | Leakage=%.2e | %s\n", 
              l, signal_mag, leakage_mag, status))
}

# ------------------------------------------------------------------------------
# 4. VISUALIZATION
# ------------------------------------------------------------------------------
cat("\n=======================================================\n")
cat("      FIT OBJECT INTEGRITY AUDIT \n")
cat("=======================================================\n")
print(results_df)

df_long <- tidyr::pivot_longer(results_df, cols = c("Signal_Strength", "Residual_Leakage"))

ggplot(df_long, aes(x=factor(Iteration), y=value, fill=name)) +
  geom_bar(stat="identity", position=position_dodge()) +
  scale_y_continuous(trans="log10") +
  labs(title="Annihilation Audit (Using fit.hybridPLS Output)",
       subtitle="Verifying orthogonality of stored W objects against stored Xi directions",
       y="Projection Magnitude (Log10)",
       x="Component") +
  theme_minimal() +
  scale_fill_manual(values=c("firebrick", "steelblue")) +
  geom_hline(yintercept=1e-10, linetype="dashed")
```


You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.

```

