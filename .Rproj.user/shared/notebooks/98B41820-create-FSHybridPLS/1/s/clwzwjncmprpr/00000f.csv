"0","#'"
"0","#' @export MFPCA"
"0","MFPCA <- function(mFData, mFData_predict, M, uniExpansions, weights = rep(1, length(mFData)), fit = FALSE, approx.eigen = FALSE,"
"0","                  bootstrap = FALSE, nBootstrap = NULL, bootstrapAlpha = 0.05, bootstrapStrat = NULL,"
"0","                  verbose = options()$verbose)"
"0","{"
"0","  if(! inherits(mFData, ""multiFunData""))"
"0","    stop(""Parameter 'mFData' must be passed as a multiFunData object."")"
"0",""
"0","  # number of components"
"0","  p <- length(mFData)"
"0","  # number of observations"
"0","  N <- nObs(mFData)"
"0",""
"0","  if(!all(is.numeric(M), length(M) == 1, M > 0))"
"0","    stop(""Parameter 'M' must be passed as a number > 0."")"
"0",""
"0","  if(!(is.list(uniExpansions) & length(uniExpansions) == p))"
"0","    stop(""Parameter 'uniExpansions' must be passed as a list with the same length as 'mFData'."")"
"0",""
"0","  if(!(is.numeric(weights) & length(weights) == p))"
"0","    stop(""Parameter 'weights' must be passed as a vector with the same length as 'mFData'."")"
"0",""
"0","  if(!is.logical(fit))"
"0","    stop(""Parameter 'fit' must be passed as a logical."")"
"0",""
"0","  if(!is.logical(approx.eigen))"
"0","    stop(""Parameter 'approx.eigen' must be passed as a logical."")"
"0",""
"0","  if(!is.logical(bootstrap))"
"0","    stop(""Parameter 'bootstrap' must be passed as a logical."")"
"0",""
"0","  if(bootstrap)"
"0","  {"
"0","    if(is.null(nBootstrap))"
"0","      stop(""Specify number of bootstrap iterations."")"
"0",""
"0","    if(any(!(0 < bootstrapAlpha & bootstrapAlpha < 1)))"
"0","      stop(""Significance level for bootstrap confidence bands must be in (0,1)."")"
"0",""
"0","    if(!is.null(bootstrapStrat))"
"0","    {"
"0","      if(!is.factor(bootstrapStrat))"
"0","        stop(""bootstrapStrat must be either NULL or a factor."")"
"0",""
"0","      if(length(bootstrapStrat) != nObs(mFData))"
"0","        stop(""bootstrapStrat must have the same length as the number of observations in the mFData object."")"
"0","    }"
"0","  }"
"0",""
"0","  if(!is.logical(verbose))"
"0","    stop(""Parameter 'verbose' must be passed as a logical."")"
"0",""
"0","  # dimension for each component"
"0","  dimSupp <- dimSupp(mFData)"
"0",""
"0","  # get type of univariate expansions"
"0","  type <- vapply(uniExpansions, function(l){l$type}, FUN.VALUE = """")"
"0",""
"0","  # de-mean functions -> coefficients are also de-meaned!"
"0","  # do not de-mean in uFPCA, as PACE gives a smooth estimate of the mean (see below)"
"0","  m <- meanFunction(mFData, na.rm = TRUE) # ignore NAs in data"
"0","  for(j in seq_len(p))"
"0","  {"
"0","    if(type[j] != ""uFPCA"")"
"0","      mFData[[j]] <- mFData[[j]] - m[[j]]"
"0","  }"
"0",""
"0","  if(verbose)"
"0","    cat(""Calculating univariate basis expansions ("", format(Sys.time(), ""%T""), "")\n"", sep = """")"
"0",""
"0",""
"0",""
"0","########### modified by Jongmin Mun #############################"
"0","  # calculate univariate basis expansion for all components"
"0","  uniBasis <- mapply("
"0","    function(expansion, data, data_predict){"
"0","      do.call(univDecomp, c("
"0","        list(funDataObject = data, funDataObject_predict = data_predict),"
"0","        expansion)"
"0","        )"
"0","      },"
"0","    expansion = uniExpansions,"
"0","    data = mFData,"
"0","    data_predict = mFData_predict,"
"0","    SIMPLIFY = FALSE"
"0","    )"
"0","########### modified by Jongmin Mun #############################"
"0",""
"0",""
"0",""
"0",""
"0",""
"0","  # for uFPCA: replace estimated mean in m"
"0","  for(j in seq_len(p))"
"0","  {"
"0","    if(type[j] == ""uFPCA"")"
"0","      m[[j]] <- uniBasis[[j]]$meanFunction"
"0","  }"
"0",""
"0","  # Multivariate FPCA"
"0","  npc <- vapply(uniBasis, function(x){dim(x$scores)[2]}, FUN.VALUE = 0) # get number of univariate basis functions"
"0",""
"0","  if(M > sum(npc))"
"0","  {"
"0","    M <- sum(npc)"
"0","    warning(""Function MFPCA: total number of univariate basis functions is smaller than given M. M was set to "", sum(npc), ""."")"
"0","  }"
"0",""
"0","  # check if non-orthonormal basis functions used"
"0","  if(all(foreach::foreach(j = seq_len(p), .combine = ""c"")%do%{uniBasis[[j]]$ortho}))"
"0","    Bchol = NULL"
"0","  else"
"0","  {"
"0","    # Cholesky decomposition of B = block diagonal of Cholesky decompositions"
"0","    Bchol <- Matrix::bdiag(lapply(uniBasis, function(l){"
"0","      if(l$ortho)"
"0","        res <- Matrix::Diagonal(n = ncol(l$scores))"
"0","      else"
"0","        res <- Matrix::chol(l$B)"
"0",""
"0","      return(res)}))"
"0","  }"
"0",""
"0","  if(verbose)"
"0","    cat(""Calculating MFPCA ("", format(Sys.time(), ""%T""), "")\n"", sep = """")"
"0",""
"0","  mArgvals <- if (utils::packageVersion(""funData"") <= ""1.2"") {"
"0","    getArgvals(mFData)"
"0","  } else {"
"0","    funData::argvals(mFData)"
"0","  }"
"0",""
"0","  res <- calcMFPCA(N = N, p = p, Bchol = Bchol, M = M, type = type, weights = weights,"
"0","                   npc = npc, argvals = mArgvals, uniBasis = uniBasis, fit = fit, approx.eigen = approx.eigen)"
"0",""
"0","  res$meanFunction <- m # return mean function, too"
"0",""
"0","  names(res$functions) <- names(mFData)"
"0",""
"0","  #############modified by jongmin mun"
"0",""
"0",""
"0","  #####################################"
"0","  if(fit)"
"0","  {"
"0","    res$fit <- m + res$fit # add mean function to fits"
"0","    names(res$fit) <- names(mFData)"
"0","  }"
"0",""
"0","  # give correct names"
"0","  namesList <- lapply(mFData, names)"
"0","  if(!all(vapply(namesList, FUN = is.null, FUN.VALUE = TRUE)))"
"0","  {"
"0","    if(length(unique(namesList)) != 1)"
"0","      warning(""Elements have different curve names. Use names of the first element for the results."")"
"0",""
"0","    row.names(res$scores) <- namesList[[1]]"
"0",""
"0","    if(fit)"
"0","      for(i in seq_len(p))"
"0","        names(res$fit[[i]]) <- namesList[[1]]"
"0","  }"
"0",""
"0",""
"0","  if(type[1] == ""uFPCA""){"
"0","    scores.pred<-calcMFPCA_predict(N = nObs(mFData_predict),"
"0","                      p = p,"
"0","                      M = M,"
"0","                      weights = weights,"
"0","                      npc = npc,"
"0","                      uniBasis = uniBasis,"
"0","                      normFactors = res$normFactors,"
"0","                      vectors_train=res$vectors,"
"0","                      values_train=res$values"
"0","    )"
"0","  }"
"0","  res$scores.pred <- scores.pred"
"0",""
"0","  class(res) <- ""MFPCAfit"""
"0","    return(res)"
"0","}"
"0",""
