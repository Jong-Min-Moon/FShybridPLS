"0","testthat::test_that(""replace_obs_hybrid correctly replaces an observation"", {"
"0","  # Setup: Create a multi-sample predictor_hybrid object"
"0","  n_samples <- 5"
"0","  n_scalar <- 2"
"0","  n_functional <- 3"
"0","  n_basis <- 5 # Assuming a fixed number of basis functions for simplicity"
"0",""
"0","  # Basis object"
"0","  basis_obj <- create.bspline.basis(c(0, 1), nbasis = n_basis)"
"0",""
"0","  # Generate sample functional data"
"0","  functional_list_initial <- lapply(1:n_functional, function(f_idx) {"
"0","    fd(matrix(rnorm(n_basis * n_samples), ncol = n_samples), basis_obj)"
"0","  })"
"0",""
"0","  # Generate sample scalar data"
"0","  Z_initial <- matrix(rnorm(n_samples * n_scalar), nrow = n_samples, ncol = n_scalar)"
"0",""
"0","  W_original <- predictor_hybrid(Z = Z_initial, functional_list = functional_list_initial)"
"0",""
"0","  # Create a single-sample predictor_hybrid object for replacement"
"0","  new_Z_scalar <- matrix(c(100, 200), nrow = 1)"
"0","  new_functional_list_single <- lapply(1:n_functional, function(f_idx) {"
"0","    fd(matrix(c(rep(10, n_basis), rep(20, n_basis), rep(30, n_basis))[f_idx * n_basis - (n_basis - 1):0], ncol = 1), basis_obj)"
"0","  })"
"0","  new_W_single <- predictor_hybrid(Z = new_Z_scalar, functional_list = new_functional_list_single)"
"0",""
"0","  # Test Case 1: Replace a middle observation (e.g., index 3)"
"0","  index_to_replace <- 3"
"0","  W_modified <- replace_obs_hybrid(W_original, index_to_replace, new_W_single)"
"0",""
"0","  # Verify scalar part"
"0","  testthat::expect_equal(W_modified$Z[index_to_replace, ], new_W_single$Z[1, ],"
"0","               info = ""Scalar part at replaced index should match new_W_single$Z"")"
"0","  # Verify other scalar rows are unchanged"
"0","  if (index_to_replace > 1) {"
"0","    testthat::expect_equal(W_modified$Z[1:(index_to_replace - 1), ], W_original$Z[1:(index_to_replace - 1), ],"
"0","                 info = ""Scalar part before replaced index should be unchanged"")"
"0","  }"
"0","  if (index_to_replace < n_samples) {"
"0","    testthat::expect_equal(W_modified$Z[(index_to_replace + 1):n_samples, ], W_original$Z[(index_to_replace + 1):n_samples, ],"
"0","                 info = ""Scalar part after replaced index should be unchanged"")"
"0","  }"
"0",""
"0","  # Verify functional part"
"0","  for (j in seq_len(n_functional)) {"
"0","    testthat::expect_equal(coef(W_modified$functional_list[[j]])[, index_to_replace],"
"0","                 coef(new_W_single$functional_list[[j]])[, 1],"
"0","                 info = paste0(""Functional predictor "", j, "" at replaced index should match new_W_single""))"
"0","    # Verify other functional columns are unchanged"
"0","    if (index_to_replace > 1) {"
"0","      testthat::expect_equal(coef(W_modified$functional_list[[j]])[, 1:(index_to_replace - 1)],"
"0","                   coef(W_original$functional_list[[j]])[, 1:(index_to_replace - 1)],"
"0","                   info = paste0(""Functional predictor "", j, "" before replaced index should be unchanged""))"
"0","    }"
"0","    if (index_to_replace < n_samples) {"
"0","      testthat::expect_equal(coef(W_modified$functional_list[[j]])[, (index_to_replace + 1):n_samples],"
"0","                   coef(W_original$functional_list[[j]])[, (index_to_replace + 1):n_samples],"
"0","                   info = paste0(""Functional predictor "", j, "" after replaced index should be unchanged""))"
"0","    }"
"0","  }"
"0",""
"0","  # Test Case 2: Replacing the first observation (index 1)"
"0","  index_to_replace <- 1"
"0","  W_modified_first <- replace_obs_hybrid(W_original, index_to_replace, new_W_single)"
"0","  testthat::expect_equal(W_modified_first$Z[index_to_replace, ], new_W_single$Z[1, ])"
"0","  for (j in seq_len(n_functional)) {"
"0","    testthat::expect_equal(coef(W_modified_first$functional_list[[j]])[, index_to_replace],"
"0","                 coef(new_W_single$functional_list[[j]])[, 1])"
"0","  }"
"0",""
"0","  # Test Case 3: Replacing the last observation (index n_samples)"
"0","  index_to_replace <- n_samples"
"0","  W_modified_last <- replace_obs_hybrid(W_original, index_to_replace, new_W_single)"
"0","  testthat::expect_equal(W_modified_last$Z[index_to_replace, ], new_W_single$Z[1, ])"
"0","  for (j in seq_len(n_functional)) {"
"0","    testthat::expect_equal(coef(W_modified_last$functional_list[[j]])[, index_to_replace],"
"0","                 coef(new_W_single$functional_list[[j]])[, 1])"
"0","  }"
"0",""
"0","  # Test Case 4: Error handling for invalid index"
"0","  testthat::expect_error(replace_obs_hybrid(W_original, 0, new_W_single), ""Index i must be between 1 and"")"
"0","  testthat::expect_error(replace_obs_hybrid(W_original, n_samples + 1, new_W_single), ""Index i must be between 1 and"")"
"0",""
"0","  # Test Case 5: Error handling for new_W with multiple samples"
"0","  multi_sample_new_W <- predictor_hybrid(Z = matrix(rnorm(2*n_scalar), nrow=2),"
"0","                                         functional_list = lapply(1:n_functional, function(f_idx) {"
"0","                                           fd(matrix(rnorm(n_basis*2), ncol = 2), basis_obj)"
"0","                                         }))"
"0","  testthat::expect_error(replace_obs_hybrid(W_original, 1, multi_sample_new_W), ""new_W must be a single-sample predictor_hybrid object."")"
"0",""
"0","  # Test Case 6: Error handling for mismatch in n_scalar"
"0","  mismatch_scalar_new_W <- predictor_hybrid(Z = matrix(rnorm(1*1), nrow=1),"
"0","                                            functional_list = new_functional_list_single)"
"0","  testthat::expect_error(replace_obs_hybrid(W_original, 1, mismatch_scalar_new_W), ""Mismatch in number of scalar predictors."")"
"0",""
"0","  # Test Case 7: Error handling for mismatch in n_functional"
"0","  mismatch_functional_new_W <- predictor_hybrid(Z = new_Z_scalar,"
"0","                                                functional_list = new_functional_list_single[1]) # Only one functional predictor"
"0","  testthat::expect_error(replace_obs_hybrid(W_original, 1, mismatch_functional_new_W), ""Mismatch in number of functional predictors."")"
"0",""
"0","  # Test Case 8: Error handling for mismatch in basis objects"
"0","  different_basis_obj <- create.bspline.basis(c(0, 1), nbasis = n_basis + 1) # Different basis"
"0","mismatch_basis_new_W_list <- lapply(1:n_functional, function(f_idx) {"
"0","  # Use the correct number of rows: nbasis of different_basis_obj"
"0","  fd(matrix(rnorm(different_basis_obj$nbasis), ncol = 1), different_basis_obj)"
"0","})"
"0","  mismatch_basis_new_W <- predictor_hybrid(Z = new_Z_scalar,"
"0","                                          functional_list = mismatch_basis_new_W_list)"
"0","  testthat::expect_error(replace_obs_hybrid(W_original, 1, mismatch_basis_new_W), ""Functional predictors must have the same basis objects."")"
"0",""
"0","})"
"1","[32mTest passed[39m ðŸ˜¸
"
