"0","#' Normalize Functional Predictors in Hybrid Objects (Train/Test Split)"
"0","#' @param train A `predictor_hybrid` object representing the training set."
"0","#' @param test A `predictor_hybrid` object representing the testing set."
"0","#' @return A list containing:"
"0","#'   \item{train}{The normalized training `predictor_hybrid` object.}"
"0","#'   \item{test}{The normalized testing `predictor_hybrid` object.}"
"0","#'   \item{deno_train}{A numeric vector of scaling factors used for each functional predictor.}"
"0","#' @export"
"0","curve_normalize_train_test <- function(train, test) {"
"0","  # --- Type Checks ---"
"0","  stopifnot("
"0","    ""'train' must be of class 'predictor_hybrid'"" = inherits(train, ""predictor_hybrid""),"
"0","    ""'test' must be of class 'predictor_hybrid'"" = inherits(test, ""predictor_hybrid""),"
"0","    ""Mismatch in number of functional predictors"" = train$n_functional == test$n_functional"
"0","  )"
"0",""
"0","  train_normalized <- train"
"0","  test_normalized <- test"
"0","  deno_train <- numeric(train$n_functional)"
"0","  mean_train <- list()"
"0","  "
"0","  # Iterate through each functional predictor (k)"
"0","  for (k in seq_len(train$n_functional)) { "
"0","    # 1. Determine centering and scaling factors from the TRAINING data only"
"0","    train_fd <- train$functional_list[[k]]"
"0","    "
"0","    # Calculate the mean function for centering"
"0","    mean_train[[k]] <- fda::mean.fd(train_fd) "
"0","    "
"0","    # Calculate the standard deviation function"
"0","    sd_train <- fda::sd.fd(train_fd)"
"0","    "
"0","    # Calculate the scaling factor (L2 norm of the standard deviation function)"
"0","    deno_train[k] <- sqrt(fda::inprod(sd_train, sd_train))"
"0","    "
"0","    # Ensure scaling factor is positive"
"0","    if (deno_train[k] <= 1e-10) {"
"0","      warning(paste(""Scaling factor for functional predictor"", k, ""is near zero. Skipping normalization for this predictor.""))"
"0","      deno_train[k] <- 1 # Set to 1 to prevent division by zero, effectively no normalization"
"0","    }"
"0",""
"0","    # 2. Normalize the TRAINING set"
"0","    train_normalized$functional_list[[k]] <- curve_normalize("
"0","      train_fd, # Use original train data"
"0","      mean_train[[k]],"
"0","      deno_train[k]"
"0","    )"
"0",""
"0","    # 3. Normalize the TEST set (using train factors to prevent leakage)"
"0","    test_normalized$functional_list[[k]] <-"
"0","      curve_normalize("
"0","        test$functional_list[[k]], # Use original test data"
"0","        mean_train, # Centered by training mean"
"0","        deno_train[k] # Scaled by training SD"
"0","      )"
"0","  }"
"0","  "
"0","  # Return the modified hybrid objects and the scaling factors"
"0","  return( list("
"0","    train = train_normalized,"
"0","    test = test_normalized,"
"0","    mean_train = mean_train,"
"0","    deno_train = deno_train"
"0","  ))"
"0","}"
