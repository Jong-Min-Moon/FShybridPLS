"0","#' Internal function that implements the MFPCA algorithm for given univariate decompositions"
"0","#' @export"
"0","#' "
"0","calcMFPCA <- function(N, p, Bchol, M, type, weights, npc, argvals, uniBasis, fit = FALSE, approx.eigen = FALSE)"
"0","{"
"0","  # combine all scores"
"0","  allScores <- foreach::foreach(j = seq_len(p), .combine = ""cbind"")%do%{uniBasis[[j]]$scores}"
"0",""
"0","  # block vector of weights"
"0","  allWeights <- foreach::foreach(j = seq_len(p), .combine = ""c"")%do%{rep(sqrt(weights[j]), npc[j])}"
"0",""
"0","  Z <- allScores %*% Matrix::Diagonal(x = allWeights) / sqrt(N-1)"
"0",""
"0","  # check if approximation is appropriate (cf. irlba)"
"0","  if(approx.eigen & (M > min(N, sum(npc))/2))"
"0","  {"
"0","    warning(""Calculating a large percentage of principal components, approximation may not be appropriate."
"0","            'approx.eigen' set to FALSE."")"
"0","    approx.eigen = FALSE"
"0","  }"
"0",""
"0","  # check if non-orthonormal basis functions used and calculate PCA on scores"
"0","  if(is.null(Bchol))"
"0","  {"
"0","    if(approx.eigen)"
"0","    {"
"0","      tmpSVD <- irlba::irlba(as.matrix(Z), nv = M)"
"0",""
"0","      vectors <- tmpSVD$v"
"0","      values <- tmpSVD$d[seq_len(M)]^2"
"0","    }"
"0","    else"
"0","    {"
"0","      if(sum(npc) > 1000)"
"0","        warning(""MFPCA with > 1000 univariate eigenfunctions and approx.eigen = FALSE. This may take some time..."")"
"0",""
"0","      e <- eigen(stats::cov(allScores) * outer(allWeights, allWeights, ""*""))"
"0",""
"0","      values <- e$values[seq_len(M)]"
"0","      vectors <- e$vectors[,seq_len(M)]"
"0","    }"
"0","  }"
"0","  else"
"0","  {"
"0","    if(approx.eigen)"
"0","    {"
"0","      tmpSVD <- irlba::irlba(as.matrix(Matrix::tcrossprod(Z, Bchol)), nv = M)"
"0",""
"0","      vectors <- Matrix::crossprod(Bchol, tmpSVD$v)"
"0","      values <- tmpSVD$d[seq_len(M)]^2"
"0","    }"
"0","    else"
"0","    {"
"0","      if(sum(npc) > 1000)"
"0","        warning(""MFPCA with > 1000 univariate eigenfunctions and approx.eigen = FALSE. This may take some time..."")"
"0",""
"0","      e <- eigen(Matrix::crossprod(Bchol) %*% (stats::cov(allScores) * outer(allWeights, allWeights, ""*"")))"
"0",""
"0","      values <- Re(e$values[seq_len(M)])"
"0","      vectors <- Re(e$vectors[,seq_len(M)])"
"0","    }"
"0","  }"
"0",""
"0","  # normalization factors"
"0","  normFactors <- 1/sqrt(diag(as.matrix(Matrix::crossprod(Z %*% vectors))))"
"0",""
"0","  ### Calculate scores"
"0","  scores <- Z %*% vectors * sqrt(N-1) # see defintion of Z above!"
"0","  scores <- as.matrix(scores %*% diag(sqrt(values) * normFactors, nrow = M, ncol = M)) # normalization"
"0",""
"0","  ### Calculate eigenfunctions (incl. normalization)"
"0","  npcCum <- cumsum(c(0, npc)) # indices for blocks (-1)"
"0",""
"0","  tmpWeights <- as.matrix(Matrix::crossprod(Z, Z %*%vectors))"
"0","  eFunctions <- foreach::foreach(j = seq_len(p)) %do% {"
"0","    univExpansion(type = type[j],"
"0","                  scores = 1/sqrt(weights[j] * values) * normFactors * t(tmpWeights[npcCum[j]+seq_len(npc[j]), , drop = FALSE]),"
"0","                  argvals = argvals[[j]],"
"0","                  functions = uniBasis[[j]]$functions,"
"0","                  params = uniBasis[[j]]$settings)"
"0","  }"
"0",""
"0","  res <- list(values = values,"
"0","              functions = multiFunData(eFunctions),"
"0","              scores = scores,"
"0","              vectors = vectors,"
"0","              values = values,"
"0","              normFactors = normFactors,"
"0","              uniBasis = uniBasis,"
"0","              uniExpansions = uniExpansions"
"0","  )"
"0",""
"0","  # calculate truncated Karhunen-Loeve representation (no mean here)"
"0","  if(fit)"
"0","    res$fit <- multivExpansion(multiFuns = res$functions, scores = scores)"
"0",""
"0","  return(res)"
"0","}"
