"0","#' @export"
"0","fit.hybridPLS <- function(W, y, n_iter, lambda) {"
"0","  # 1. Initialize storage"
"0","  W_now <- rho <- xi <- delta <- nu  <- iota <- beta <- list()"
"0"," "
"0","  # 3. Initialize residuals"
"0","  W_now[[1]] <- W"
"0","  y_now <- y"
"0","  final_succesful_iteration <- 0"
"0","  constr_mat <- get_constraint_matrix_hybrid(W, lambda)"
"0","  constr_mat_chol <- t(chol(constr_mat))"
"0","  for (l in 1:n_iter) {"
"0","    cat(paste(l, ""th component"", ""\n""))"
"0",""
"0","    xi[[l]]  <- get_xi_hat_linear_pen(W_now[[l]], y_now, lambda) # PLS direction"
"0","    rho[[l]] <- inprod.predictor_hybrid(W_now[[l]], xi[[l]]) #PLS score"
"0","    delta[[l]] <- get_delta(W_now[[l]], rho[[l]]);  "
"0","    W_now[[l + 1]] <- residualize_predictor(W_now[[l]], rho[[l]], delta[[l]]) # predictor residual"
"0","    nu[[l]] <- get_nu(y_now, rho[[l]]); y_now <- residualize_y(y_now, rho[[l]], nu[[l]]) # response residual"
"0"," "
"0","    iota[[l]] <- xi[[l]]"
"0","    if (l == 1) {"
"0","      beta[[l]] <- scalar_mul.predictor_hybrid( iota[[l]], nu[[l]] )"
"0","    } else {"
"0","      for (u in 1:(l - 1)) iota[[l]] <- subtr.predictor_hybrid( iota[[l]], iota[[u]], inprod.predictor_hybrid(delta[[u]], xi[[l]]))"
"0","      beta[[l]] <- add.predictor_hybrid(beta[[l - 1]], iota[[l]], nu[[l]])"
"0","    }"
"0","  }"
"0","  return (list("
"0","    rho = rho,"
"0","    xi = xi,"
"0","    W = W_now,"
"0","    beta = beta"
"0","  ))"
"0","}"
"0",""
