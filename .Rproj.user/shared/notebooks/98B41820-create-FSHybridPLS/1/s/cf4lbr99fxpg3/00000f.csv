"0","#' @export"
"0","fit.hybridPLS <- function(W, y, n_iter, lambda) {"
"0","  # 1. Initialize storage"
"0","  W_now <- rho <- xi <- delta <- nu  <- sigma <- eta <- list()"
"0"," "
"0","  # 3. Initialize residuals"
"0","  W_now[[1]] <- W"
"0","  y_now <- y"
"0","  final_succesful_iteration <- 0"
"0",""
"0","  for (l in 1:n_iter) {"
"0","    cat(paste(l, ""th component"", ""\n""))"
"0",""
"0","    xi[[l]]  <- get_xi_hat_linear_pen(W_now[[l]], y_now, lambda) # PLS direction"
"0","    rho[[l]] <- inprod.predictor_hybrid(W_now[[l]], xi[[l]]) #PLS score"
"0","    delta[[l]] <- get_delta(W_now[[l]], rho[[l]]);  "
"0","    W_now[[l + 1]] <- residualize_predictor(W_now[[l]], rho[[l]], delta[[l]]) # predictor residual"
"0","    nu[[l]] <- get_nu(y_now, rho[[l]]); y_now <- residualize_y(y_now, rho[[l]], nu[[l]]) # response residual"
"0"," "
"0","    # Step 3: Orthogonalize and update prediction"
"0","    #sigma[[l]] <- xi[[l]]"
"0","    #if (l == 1) {"
"0","    #  eta[[l]] <- scalar_mul(sigma[[l]], nu[[l]])"
"0","    #} else {"
"0","    #  for (u in 1:(l - 1)) {"
"0","    #    sigma[[l]] <- subtr(sigma[[l]], sigma[[u]], hybrid_inner_prod(delta[[u]], xi[[l]]))"
"0","    #  }"
"0","    #  eta[[l]] <- add(eta[[l - 1]], sigma[[l]], nu[[l]])"
"0","    #}"
"0","  }"
"0","}"
"0",""
