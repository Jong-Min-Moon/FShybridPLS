"0","#' Scale the scalar predictors so that the variability between the"
"0","#' functional and scalar predictors are comparable."
"0","#'"
"0","#' This method calculates a scaling factor (sqrt(omega)) from the training"
"0","#' set, defined as the ratio of the total sum of squares (L2 norms) of all"
"0","#' functional components to the total sum of squares of all scalar components."
"0","#'"
"0","#' @param train A predictor_hybrid object representing the training data."
"0","#' @param test A predictor_hybrid object representing the test data."
"0","#'"
"0","#' @return A list containing the normalized 'train' and 'test' predictor_hybrid objects."
"0","#' @export"
"0","btwn_normalize_train_test <- function(train, test){"
"0","  "
"0","  # Type checks"
"0","  stopifnot("
"0","    ""'train' must be of class 'predictor_hybrid'"" = inherits(train, ""predictor_hybrid""),"
"0","    ""'test' must be of class 'predictor_hybrid'"" = inherits(test, ""predictor_hybrid"")"
"0","  )"
"0","  "
"0","  # Create copies for modification"
"0","  train_normalized <- train"
"0","  test_normalized <- test"
"0","  "
"0","  # Z_s for clarity in calculation"
"0","  Z_s <- train$Z "
"0","  "
"0","  # --- 1. Calculate the numerator of omega (Sum of L2 norms of all functional samples in train) ---"
"0","  omega_numerator <- 0"
"0","  "
"0","  for (k in seq_len(train$n_functional)){ # for kth functional predictor"
"0","    # fda::inprod(fd, fd) returns the N x N matrix of inner products."
"0","    # The diagonal elements are the L2 norm squared for each sample."
"0","    functional_inprod_matrix <- fda::inprod("
"0","      train$functional_list[[k]],"
"0","      train$functional_list[[k]]"
"0","    )"
"0","    "
"0","    # Sum the diagonal to get the total squared norm for this predictor k"
"0","    omega_numerator <- omega_numerator + sum(diag(functional_inprod_matrix))"
"0","  }"
"0","  "
"0","  # --- 2. Calculate the denominator of omega (Sum of squares of all scalar samples in train) ---"
"0","  omega_denominator <- sum(Z_s^2)"
"0","  "
"0","  # Handle case where scalar variance is zero (prevent division by zero)"
"0","  if (omega_denominator == 0) {"
"0","    warning(""Scalar component sum of squares is zero. No scaling applied."")"
"0","    omega <- 1"
"0","  } else {"
"0","    # Calculate the scaling factor omega"
"0","    omega <- omega_numerator / omega_denominator"
"0","  }"
"0","  "
"0","  # --- 3. Apply scaling factor sqrt(omega) to both train and test scalar components ---"
"0","  scaling_factor <- sqrt(omega)"
"0","  "
"0","  train_normalized$Z <- scaling_factor * (train$Z)"
"0","  test_normalized$Z <- scaling_factor * (test$Z)"
"0","  "
"0","  return("
"0","    list("
"0","      predictor_train = train_normalized,"
"0","      predictor_test = test_normalized,"
"0","      scaling_factor = scaling_factor"
"0","    )"
"0","  )"
"0","}"
"0",""
