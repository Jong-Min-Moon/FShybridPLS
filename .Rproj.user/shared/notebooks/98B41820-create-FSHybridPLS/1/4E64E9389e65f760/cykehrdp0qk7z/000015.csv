"0","# NOTE: This script requires the 'fda' package to be loaded (e.g., library(fda))."
"0","if (!requireNamespace(""fda"", quietly = TRUE)) {"
"0","  stop(""The 'fda' package is required for this test."")"
"0","}"
"0","library(fda)"
"0",""
"0","# --- DEPENDENCIES ---"
"0",""
"0","# 1. Minimal Working predictor_hybrid Constructor (Required for testing)"
"0","predictor_hybrid <- function(Z, functional_list) {"
"0","  stopifnot(is.matrix(Z), is.numeric(Z))"
"0","  n_sample <- nrow(Z)"
"0","  n_scalar <- ncol(Z)"
"0","  n_functional <- length(functional_list)"
"0","  "
"0","  # Mock values for components not strictly needed for this test"
"0","  mock_gram <- matrix(0, 1, 1) "
"0","  "
"0","  structure("
"0","    list("
"0","      Z = Z,"
"0","      functional_list = functional_list,"
"0","      gram_list = rep(list(mock_gram), n_functional),"
"0","      gram_deriv2_list = rep(list(mock_gram), n_functional),"
"0","      n_basis_list = vapply(functional_list, function(f) f$basis$nbasis, numeric(1)),"
"0","      n_sample = n_sample,"
"0","      n_functional = n_functional,"
"0","      n_scalar = n_scalar"
"0","    ),"
"0","    class = ""predictor_hybrid"""
"0","  )"
"0","}"
"0",""
"0",""
"0",""
"0","# --- TEST SETUP ---"
"0",""
"0","N_TRAIN <- 10 # Training samples"
"0","N_TEST <- 5   # Test samples"
"0","K_FUN <- 2    # Functional predictors"
"0","P_SCALAR <- 1 # Scalar predictors"
"0","NBASIS <- 7   # Number of basis functions"
"0",""
"0","# Create Basis"
"0","basis_obj <- create.bspline.basis(rangeval = c(0, 10), nbasis = NBASIS)"
"0",""
"0","# --- Mock Training Data ---"
"0","Z_train <- matrix(rnorm(N_TRAIN * P_SCALAR), nrow = N_TRAIN, ncol = P_SCALAR)"
"0","F_list_train <- lapply(1:K_FUN, function(k) {"
"0","  coefs <- matrix(rnorm(N_TRAIN * NBASIS, mean = 5 + k, sd = 2), nrow = NBASIS, ncol = N_TRAIN)"
"0","  fd(coef = coefs, basisobj = basis_obj)"
"0","})"
"0","W_train <- predictor_hybrid(Z = Z_train, functional_list = F_list_train)"
"0",""
"0","# --- Mock Test Data ---"
"0","Z_test <- matrix(rnorm(N_TEST * P_SCALAR), nrow = N_TEST, ncol = P_SCALAR)"
"0","F_list_test <- lapply(1:K_FUN, function(k) {"
"0","  coefs <- matrix(rnorm(N_TEST * NBASIS, mean = 10 + k, sd = 3), nrow = NBASIS, ncol = N_TEST) # Different mean/sd to ensure train stats are used"
"0","  fd(coef = coefs, basisobj = basis_obj)"
"0","})"
"0","W_test <- predictor_hybrid(Z = Z_test, functional_list = F_list_test)"
"0",""
"0","cat(""--- Running curve_normalize_train_test Test ---\n"")"
"1","--- Running curve_normalize_train_test Test ---
"
"0","# --- EXECUTE FUNCTION ---"
"0","results <- curve_normalize_train_test(W_train, W_test)"
"0","W_train_norm <- results$train"
"0","W_test_norm <- results$test"
"0","deno_train <- results$deno_train"
"0",""
"0","test_passed <- TRUE"
"0",""
"0","# --- TEST 1: Check Class and Structure ---"
"0","if (!inherits(W_train_norm, ""predictor_hybrid"") || !inherits(W_test_norm, ""predictor_hybrid"")) {"
"0","  cat(""Test FAILED: Normalized objects are not of class 'predictor_hybrid'.\n"")"
"0","  test_passed <- FALSE"
"0","}"
"0",""
"0","# --- TEST 2: Check Scalar Predictors (Z) are UNCHANGED ---"
"0","if (!isTRUE(all.equal(W_train_norm$Z, W_train$Z))) {"
"0","  cat(""Test FAILED: Training scalar predictors (Z) were modified.\n"")"
"0","  test_passed <- FALSE"
"0","}"
"0","if (!isTRUE(all.equal(W_test_norm$Z, W_test$Z))) {"
"0","  cat(""Test FAILED: Test scalar predictors (Z) were modified.\n"")"
"0","  test_passed <- FALSE"
"0","}"
"0",""
"0","# --- TEST 3: Verify Functional Normalization Logic (Predictor 1) ---"
"0",""
"0","k <- 1 # Focus on the first functional predictor"
"0","F_train_k <- W_train$functional_list[[k]]"
"0","F_train_norm_k <- W_train_norm$functional_list[[k]]"
"0","F_test_k <- W_test$functional_list[[k]]"
"0","F_test_norm_k <- W_test_norm$functional_list[[k]]"
"0",""
"0","# Calculate reference train mean and scaling factor"
"0","C_train_mean <- as.matrix(coef(fda::mean.fd(F_train_k)))"
"0","D_train <- deno_train[k]"
"0",""
"0","# Reference Calculation for TRAIN set"
"0","C_train_orig <- coef(F_train_k)"
"0","C_train_ref_norm <- (C_train_orig - C_train_mean %*% matrix(1, ncol = N_TRAIN)) / D_train"
"0","C_train_actual_norm <- coef(F_train_norm_k)"
"0",""
"0","if (!isTRUE(all.equal(C_train_actual_norm, C_train_ref_norm))) {"
"0","  cat(""Test FAILED: Training functional coefficients (k=1) were not correctly normalized.\n"")"
"0","  test_passed <- FALSE"
"0","}"
"0",""
"0","# Reference Calculation for TEST set (Crucially uses TRAIN stats)"
"0","C_test_orig <- coef(F_test_k)"
"0","C_test_ref_norm <- (C_test_orig - C_train_mean %*% matrix(1, ncol = N_TEST)) / D_train"
"0","C_test_actual_norm <- coef(F_test_norm_k)"
"0",""
"0","if (!isTRUE(all.equal(C_test_actual_norm, C_test_ref_norm))) {"
"0","  cat(""Test FAILED: Test functional coefficients (k=1) were not correctly normalized using TRAINING stats.\n"")"
"0","  test_passed <- FALSE"
"0","}"
"0",""
"0","# --- FINAL RESULT ---"
"0","if (test_passed) {"
"0","  cat(""\nALL TESTS PASSED: Structural integrity and normalization logic confirmed.\n"")"
"0","} else {"
"0","  cat(""\nONE OR MORE TESTS FAILED.\n"")"
"0","}"
"1","
ALL TESTS PASSED: Structural integrity and normalization logic confirmed.
"
