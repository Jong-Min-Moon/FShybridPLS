"0","#' Inner product between two predictor_hybrid objects (with broadcasting)"
"0","#'"
"0","#' Computes the inner product between two `predictor_hybrid` objects,"
"0","#' including both functional and scalar components. Supports broadcasting"
"0","#' when one of the inputs has a single observation."
"0","#'"
"0","#' @param xi_1 A `predictor_hybrid` object."
"0","#' @param xi_2 Another `predictor_hybrid` object. If missing, defaults to `xi_1`."
"0","#'"
"0","#' @return A numeric vector of inner products, or a scalar if both inputs contain a single observation."
"0","#' @export"
"0","inprod.predictor_hybrid <- function(xi_1, xi_2 = NULL) {"
"0","  # Handle self-inner product"
"0","  if (is.null(xi_2)) xi_2 <- xi_1 "
"0","  "
"0","  # Type checks"
"0","  if (!inherits(xi_1, ""predictor_hybrid"") || !inherits(xi_2, ""predictor_hybrid"")) {"
"0","    stop(""Both inputs must be of class 'predictor_hybrid'."")"
"0","  }"
"0",""
"0","  # Structural checks"
"0","  if (xi_1$n_functional != xi_2$n_functional) {"
"0","    stop(""Mismatch in number of functional predictors."")"
"0","  }"
"0","  if (xi_1$n_scalar != xi_2$n_scalar) {"
"0","    stop(""Mismatch in number of scalar predictors."")"
"0","  }"
"0",""
"0","  # Swap so that broadcasting always applies to xi_2"
"0","  if (xi_1$n_sample == 1 && xi_2$n_sample > 1) {"
"0","    tmp <- xi_1"
"0","    xi_1 <- xi_2"
"0","    xi_2 <- tmp"
"0","  }"
"0",""
"0","  n1 <- xi_1$n_sample"
"0","  n2 <- xi_2$n_sample"
"0",""
"0","  if (!(n1 == n2 || n2 == 1)) {"
"0","    stop(""Sample sizes are incompatible for broadcasting."")"
"0","  }"
"0",""
"0","  # Prepare components"
"0","  f1 <- xi_1$functional_list"
"0","  f2 <- xi_2$functional_list"
"0","  Z1 <- xi_1$Z"
"0","  Z2 <- xi_2$Z"
"0",""
"0","  # Replicate fd and Z if needed"
"0","  if (n2 == 1) {"
"0","    f2 <- rep_fd(f2, n1)"
"0","    Z2 <- matrix(rep(c(Z2), n1), nrow = n1, byrow = TRUE)"
"0","  }"
"0",""
"0","  # Compute functional inner products"
"0","  inprod_functional <- vapply(seq_len(n1), function(i) {"
"0","    sum(vapply(seq_along(f1), function(j) {"
"0","      fda::inprod(f1[[j]][i], f2[[j]][i])"
"0","    }, numeric(1)))"
"0","  }, numeric(1))"
"0"," "
"0",""
"0","  # Compute scalar inner products"
"0","  inprod_scalar <- rowSums(Z1 * Z2) "
"0"," "
"0","  # Combine results"
"0","  result <- inprod_functional + inprod_scalar"
"0","  if (n1 == 1 && n2 == 1) as.numeric(result) else result"
"0","}"
