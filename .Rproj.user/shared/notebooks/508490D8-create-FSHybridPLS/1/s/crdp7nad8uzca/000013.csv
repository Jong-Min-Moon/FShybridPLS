"0","library(fda)"
"0",""
"0","# --- Step 1: Simulate Data ---"
"0","set.seed(777)"
"0",""
"0","n_sample <- 100"
"0","n_scalar <- 2"
"0","n_basis <- 5"
"0","n_functional <- 2"
"0",""
"0","# Scalar predictors Z (centered)"
"0","Z <- matrix(rnorm(n_sample * n_scalar), ncol = n_scalar)"
"0","Z <- scale(Z, center = TRUE, scale = FALSE)"
"0",""
"0","# Create functional predictors (centered)"
"0","basis <- create.bspline.basis(c(0, 1), nbasis = n_basis)"
"0","functional_list <- list()"
"0","for (j in 1:n_functional) {"
"0","  coefs <- matrix(rnorm(n_basis * n_sample), nrow = n_basis)"
"0","  fdobj <- fd(coef = coefs, basisobj = basis)"
"0","  mean_fd <- mean.fd(fdobj)"
"0","  mean_coef <- coef(mean_fd)"
"0","  centered_coefs <- coefs - matrix(mean_coef, nrow = n_basis, ncol = n_sample)"
"0","  functional_list[[j]] <- fd(coef = centered_coefs, basisobj = basis)"
"0","}"
"0",""
"0","# --- Step 2: Construct hybrid object ---"
"0","W <- predictor_hybrid(Z = Z, functional_list = functional_list)"
"0",""
"0","# --- Step 3: Simulate and center response ---"
"0","total_coef_len <- sum(W$n_basis_list) + W$n_scalar"
"0","true_coef <- rnorm(total_coef_len)"
"0",""
"0","# Flatten design matrix"
"0","Xmat <- matrix(NA, n_sample, total_coef_len)"
"0","for (i in 1:n_sample) {"
"0","  W_i <- subset_predictor_hybrid(W, i)"
"0","  func_coefs <- do.call(c, lapply(W_i$functional_list, function(fdobj) as.vector(coef(fdobj))))"
"0","  Xmat[i, ] <- c(func_coefs, W_i$Z)"
"0","}"
"0",""
"0","y <- Xmat %*% true_coef + rnorm(n_sample, sd = 0.1)"
"0","y <- as.vector(scale(y, center = TRUE, scale = FALSE))"
"0",""
"0","# --- Step 4: Compute constraint matrix ---"
"0","lambda <- rep(0, W$n_functional)"
"0","constr_mat <- get_constraint_matrix_hybrid(W, lambda)"
"0","L <- chol(constr_mat)"
"0",""
"0","# --- Step 5: Run eigen-based PLS ---"
"0","W_template <- W  # prevent mutation"
"0",""
"0",""
"0","pls_eig_result <- get_pls_comp(W, y, L)"
"0","xi_hat_eig <- pls_eig_result$xi_hat"
"0",""
"0","xi_hat_lin <- get_xi_hat_linear(W, y)"
"0",""
"0","# Wrap into predictor_hybrid object using format template"
"0","xi_hat_direct <- predictor_hybrid_from_coef(format = W_template, coef = xi_hat_lin)"
"0",""
"0","# Normalize"
"0","norm_val <- sqrt(inprod.predictor_hybrid(xi_hat_direct))"
"0","xi_hat_direct <- scalar_mul.predictor_hybrid(xi_hat_direct,  1 / norm_val)"
"0",""
"0",""
"0","# --- Step 7: Compare and evaluate ---"
"0","ip <- inprod.predictor_hybrid(xi_hat_eig, xi_hat_direct)"
"0","norm1 <- sqrt(inprod.predictor_hybrid(xi_hat_eig))"
"0","xi_hat_eig <- scalar_mul.predictor_hybrid(xi_hat_eig,  1 / norm1)"
"0",""
"0","norm2 <- sqrt(inprod.predictor_hybrid(xi_hat_direct))"
"0","cat(""norm 1"", norm1,  ""\n"")"
"1","norm 1 1.039818 
"
"0","cat(""norm 2"", norm2,  ""\n"")"
"1","norm 2 1 
"
"0","cos_theta <- ip / (norm1 * norm2)"
"0",""
"0","cat(""Cosine similarity between eigen-based and direct PLS components:"", cos_theta, ""\n"")"
"1","Cosine similarity between eigen-based and direct PLS components: 0.9727659 
"
"0","cat(""Projection score (eig):"", sum(inprod.predictor_hybrid(xi_hat_eig, W) * y), ""\n"")"
"1","Projection score (eig): 234.5842 
"
"0","cat(""Projection score (direct):"", sum(inprod.predictor_hybrid(xi_hat_direct, W) * y), ""\n"")"
"1","Projection score (direct): 241.1519 
"
"0","# --- Step 8: Plot functional coefficients ---"
"0","par(mfrow = c(n_functional, 1), mar = c(4, 4, 2, 2))"
"0","for (j in 1:n_functional) {"
"0","  plot(xi_hat_eig$functional_list[[j]], col = ""blue"", ylim = c(-1, 1),"
"0","       main = paste(""Functional Component"", j), ylab = ""Coefficient"", xlab = ""t"")"
"0","  lines(xi_hat_direct$functional_list[[j]], col = ""red"", lty = 2)"
"0","  legend(""topright"", legend = c(""Eigen-based"", ""Direct""), col = c(""blue"", ""red""), lty = 1:2)"
"0","}"
"0",""
