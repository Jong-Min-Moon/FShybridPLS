---
title: "Creating the ``r params$package_name`` R package"
author: "Your Name"
date: "The Date"
knit: litr::render
output: litr::litr_html_document
params:
  package_name: "FSHybridPLS" # <-- change this to your package name
  package_parent_dir: "." # <-- relative to this file's location
---

<!-- This Rmd file contains all the code needed to define an R package.  Press "Knit" in RStudio or more generally run `litr::render("name-of-this-file.Rmd")` to generate the R package.  Remember that when you want to modify anything about the R package, you should modify this document rather than the package that is outputted.
-->

## Package setup

We start by specifying the information needed in the DESCRIPTION file of the R package.

```{r package-setup, message=FALSE, results='hide'}
usethis::create_package(
  path = ".",
  fields = list(
    Package = params$package_name,
    Version = "0.0.0.9000",
    Title = "A Package That Says Hello",
    Description = "This package says hello.  But its actual purpose is to show how an R package can be completely coded in a single R markdown file.",
    `Authors@R` = person(
      given = "First",
      family = "Last",
      email = "you@gmail.com",
      role = c("aut", "cre")
      )
  )
)
usethis::use_mit_license(copyright_holder = "F. Last")
```

# Class predictor_hybrid
The `predictor_hybrid` class is an S3 object for representing hybrid predictors: a combination of scalar and functional covariates. The following code defines the class.

```{r define-class}
#' Create a predictor_hybrid object (S3 version)
#'
#' Constructs a hybrid predictor object that stores both scalar and functional predictors,
#' along with Jacobians and metadata.
#'
#' @param Z A numeric matrix of dimension \code{n_sample Ã— n_scalar} representing scalar predictors.
#' @param functional_list A list of functional predictors (e.g., \code{fd} objects from the \code{fda} package).
#' @param jacobian_list A list of Jacobian matrices corresponding to the functional predictors.
#' @param n_basis_list A numeric vector indicating the number of basis functions for each functional predictor.
#' @param n_sample Number of observations (samples).
#' @param n_functional Number of functional predictors.
#' @param n_scalar Number of scalar predictors.
#'
#' @return A list of class \code{predictor_hybrid}.
#' @export
predictor_hybrid <- function(Z, functional_list, jacobian_list,
                             n_basis_list, n_sample, n_functional, n_scalar) {
  stopifnot(is.matrix(Z))
  stopifnot(length(functional_list) == n_functional)
  stopifnot(length(jacobian_list) == n_functional)
  stopifnot(length(n_basis_list) == n_functional)
  
  structure(
    list(
      Z = Z,
      functional_list = functional_list,
      jacobian_list = jacobian_list,
      n_basis_list = n_basis_list,
      n_sample = n_sample,
      n_functional = n_functional,
      n_scalar = n_scalar
    ),
    class = "predictor_hybrid"
  )
}


```
Let's write some tests to make sure the function behaves as desired:
```{r}
testthat::test_that("predictor_hybrid constructor works as expected (S3)", {
  Z <- matrix(rnorm(100 * 5), nrow = 100, ncol = 5)
  fd1 <- list(fdobj = "fd1 placeholder")
  fd2 <- list(fdobj = "fd2 placeholder")
  J1 <- matrix(runif(100), nrow = 10)
  J2 <- matrix(runif(200), nrow = 20)
  
  obj <- predictor_hybrid(
    Z = Z,
    functional_list = list(fd1, fd2),
    jacobian_list = list(J1, J2),
    n_basis_list = c(10, 20),
    n_sample = 100,
    n_functional = 2,
    n_scalar = 5
  )
  
  testthat::expect_s3_class(obj, "predictor_hybrid")
  testthat::expect_equal(nrow(obj$Z), 100)
  testthat::expect_equal(ncol(obj$Z), 5)
  testthat::expect_equal(length(obj$functional_list), 2)
  testthat::expect_equal(length(obj$jacobian_list), 2)
  testthat::expect_equal(obj$n_basis_list, c(10, 20))
  testthat::expect_equal(obj$n_sample, 100)
  testthat::expect_equal(obj$n_functional, 2)
  testthat::expect_equal(obj$n_scalar, 5)
})


```

Code chunks that have one or more lines starting with `test_that(` (or `testthat::test_that(`) are added to the package as tests.

## Documenting the package and building

We finish by running commands that will document, build, and install the package.  It may also be a good idea to check the package from within this file.

```{r}
litr::document() # <-- use instead of devtools::document()
# devtools::build()
# devtools::install()
# devtools::check(document = FALSE)
```


